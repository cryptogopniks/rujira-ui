// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               unknown
// source: types/query_quotes.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "../../binary";
import { DeepPartial, Exact, isSet } from "../../helpers";
export const protobufPackage = "types";

export interface QueryQuoteSwapRequest {
  fromAsset: string;
  toAsset: string;
  amount: string;
  streamingInterval: string;
  streamingQuantity: string;
  destination: string;
  toleranceBps: string;
  refundAddress: string;
  affiliate: string[];
  affiliateBps: string[];
  height: string;
}

export interface QueryQuoteSwapResponse {
  /** the inbound address for the transaction on the source chain */
  inboundAddress: string;
  /** the approximate number of source chain blocks required before processing */
  inboundConfirmationBlocks: number;
  /** the approximate seconds for block confirmations required before processing */
  inboundConfirmationSeconds: number;
  /** the number of thorchain blocks the outbound will be delayed */
  outboundDelayBlocks: number;
  /** the approximate seconds for the outbound delay before it will be sent */
  outboundDelaySeconds: number;
  fees: QuoteFees | undefined;
  /** the EVM chain router contract address */
  router: string;
  /** expiration timestamp in unix seconds */
  expiry: number;
  /** static warning message */
  warning: string;
  /** chain specific quote notes */
  notes: string;
  /** Defines the minimum transaction size for the chain in base units (sats, wei, uatom). Transactions with asset amounts lower than the dust_threshold are ignored. */
  dustThreshold: string;
  /** The recommended minimum inbound amount for this transaction type & inbound asset. Sending less than this amount could result in failed refunds. */
  recommendedMinAmountIn: string;
  /** the recommended gas rate to use for the inbound to ensure timely confirmation */
  recommendedGasRate: string;
  /** the units of the recommended gas rate */
  gasRateUnits: string;
  /** generated memo for the swap */
  memo: string;
  /** the amount of the target asset the user can expect to receive after fees */
  expectedAmountOut: string;
  /** the amount of the target asset the user can expect to receive after fees */
  maxStreamingQuantity: number;
  /** the number of blocks the streaming swap will execute over */
  streamingSwapBlocks: number;
  /** approx the number of seconds the streaming swap will execute over */
  streamingSwapSeconds: number;
  /** total number of seconds a swap is expected to take (inbound conf + streaming swap + outbound delay) */
  totalSwapSeconds: number;
}

export interface QueryQuoteSaverDepositRequest {
  asset: string;
  amount: string;
  affiliate: string[];
  affiliateBps: string[];
  height: string;
}

export interface QueryQuoteSaverDepositResponse {
  /** the inbound address for the transaction on the source chain */
  inboundAddress: string;
  /** the approximate number of source chain blocks required before processing */
  inboundConfirmationBlocks: number;
  /** the approximate seconds for block confirmations required before processing */
  inboundConfirmationSeconds: number;
  /** the number of thorchain blocks the outbound will be delayed */
  outboundDelayBlocks: number;
  /** the approximate seconds for the outbound delay before it will be sent */
  outboundDelaySeconds: number;
  fees: QuoteFees | undefined;
  /** the EVM chain router contract address */
  router: string;
  /** expiration timestamp in unix seconds */
  expiry: number;
  /** static warning message */
  warning: string;
  /** chain specific quote notes */
  notes: string;
  /** Defines the minimum transaction size for the chain in base units (sats, wei, uatom). Transactions with asset amounts lower than the dust_threshold are ignored. */
  dustThreshold: string;
  /** The recommended minimum inbound amount for this transaction type & inbound asset. Sending less than this amount could result in failed refunds. */
  recommendedMinAmountIn: string;
  /** the recommended gas rate to use for the inbound to ensure timely confirmation */
  recommendedGasRate: string;
  /** the units of the recommended gas rate */
  gasRateUnits: string;
  /** generated memo for the deposit */
  memo: string;
  /** same as expected_amount_deposit, to be deprecated in favour of expected_amount_deposit */
  expectedAmountOut: string;
  /** the amount of the target asset the user can expect to deposit after fees */
  expectedAmountDeposit: string;
}

export interface QueryQuoteSaverWithdrawRequest {
  asset: string;
  address: string;
  withdrawBps: string;
  height: string;
}

export interface QueryQuoteSaverWithdrawResponse {
  /** the inbound address for the transaction on the source chain */
  inboundAddress: string;
  /** the approximate number of source chain blocks required before processing */
  inboundConfirmationBlocks: number;
  /** the approximate seconds for block confirmations required before processing */
  inboundConfirmationSeconds: number;
  /** the number of thorchain blocks the outbound will be delayed */
  outboundDelayBlocks: number;
  /** the approximate seconds for the outbound delay before it will be sent */
  outboundDelaySeconds: number;
  fees: QuoteFees | undefined;
  /** the EVM chain router contract address */
  router: string;
  /** expiration timestamp in unix seconds */
  expiry: number;
  /** static warning message */
  warning: string;
  /** chain specific quote notes */
  notes: string;
  /** Defines the minimum transaction size for the chain in base units (sats, wei, uatom). Transactions with asset amounts lower than the dust_threshold are ignored. */
  dustThreshold: string;
  /** The recommended minimum inbound amount for this transaction type & inbound asset. Sending less than this amount could result in failed refunds. */
  recommendedMinAmountIn: string;
  /** the recommended gas rate to use for the inbound to ensure timely confirmation */
  recommendedGasRate: string;
  /** the units of the recommended gas rate */
  gasRateUnits: string;
  /** generated memo for the withdraw, the client can use this OR send the dust amount */
  memo: string;
  /** the dust amount of the target asset the user should send to initialize the withdraw, the client can send this OR provide the memo */
  dustAmount: string;
  /** the amount of the target asset the user can expect to withdraw after fees in 1e8 decimals */
  expectedAmountOut: string;
}

export interface QueryQuoteLoanOpenRequest {
  fromAsset: string;
  toAsset: string;
  amount: string;
  minOut: string;
  destination: string;
  affiliate: string[];
  affiliateBps: string[];
  height: string;
}

export interface QueryQuoteLoanOpenResponse {
  /** the inbound address for the transaction on the source chain */
  inboundAddress: string;
  /** the approximate number of source chain blocks required before processing */
  inboundConfirmationBlocks: number;
  /** the approximate seconds for block confirmations required before processing */
  inboundConfirmationSeconds: number;
  /** the number of thorchain blocks the outbound will be delayed */
  outboundDelayBlocks: number;
  /** the approximate seconds for the outbound delay before it will be sent */
  outboundDelaySeconds: number;
  fees: QuoteFees | undefined;
  /** the EVM chain router contract address */
  router: string;
  /** expiration timestamp in unix seconds */
  expiry: number;
  /** static warning message */
  warning: string;
  /** chain specific quote notes */
  notes: string;
  /** Defines the minimum transaction size for the chain in base units (sats, wei, uatom). Transactions with asset amounts lower than the dust_threshold are ignored. */
  dustThreshold: string;
  /** The recommended minimum inbound amount for this transaction type & inbound asset. Sending less than this amount could result in failed refunds. */
  recommendedMinAmountIn: string;
  /** the recommended gas rate to use for the inbound to ensure timely confirmation */
  recommendedGasRate: string;
  /** the units of the recommended gas rate */
  gasRateUnits: string;
  /** generated memo for the loan open */
  memo: string;
  /** the amount of the target asset the user can expect to receive after fees in 1e8 decimals */
  expectedAmountOut: string;
  /** the expected collateralization ratio in basis points */
  expectedCollateralizationRatio: string;
  /** the expected amount of collateral increase on the loan */
  expectedCollateralDeposited: string;
  /** the expected amount of TOR debt increase on the loan */
  expectedDebtIssued: string;
  /** The number of blocks involved in the streaming swaps during the open loan process. */
  streamingSwapBlocks: number;
  /** The approximate number of seconds taken by the streaming swaps involved in the open loan process. */
  streamingSwapSeconds: number;
  /** The total expected duration for a open loan, measured in seconds, which includes the time for inbound confirmation, the duration of streaming swaps, and any outbound delays. */
  totalOpenLoanSeconds: number;
}

export interface QueryQuoteLoanCloseRequest {
  fromAsset: string;
  toAsset: string;
  minOut: string;
  repayBps: string;
  loanOwner: string;
  height: string;
}

export interface QueryQuoteLoanCloseResponse {
  /** the inbound address for the transaction on the source chain */
  inboundAddress: string;
  /** the approximate number of source chain blocks required before processing */
  inboundConfirmationBlocks: number;
  /** the approximate seconds for block confirmations required before processing */
  inboundConfirmationSeconds: number;
  /** the number of thorchain blocks the outbound will be delayed */
  outboundDelayBlocks: number;
  /** the approximate seconds for the outbound delay before it will be sent */
  outboundDelaySeconds: number;
  fees: QuoteFees | undefined;
  /** the EVM chain router contract address */
  router: string;
  /** expiration timestamp in unix seconds */
  expiry: number;
  /** static warning message */
  warning: string;
  /** chain specific quote notes */
  notes: string;
  /** Defines the minimum transaction size for the chain in base units (sats, wei, uatom). Transactions with asset amounts lower than the dust_threshold are ignored. */
  dustThreshold: string;
  /** The recommended minimum inbound amount for this transaction type & inbound asset. Sending less than this amount could result in failed refunds. */
  recommendedMinAmountIn: string;
  /** the recommended gas rate to use for the inbound to ensure timely confirmation */
  recommendedGasRate: string;
  /** the units of the recommended gas rate */
  gasRateUnits: string;
  /** generated memo for the loan close */
  memo: string;
  /** the amount of collateral asset the user can expect to receive after fees in 1e8 decimals */
  expectedAmountOut: string;
  /** The quantity of the repayment asset to be sent by the user, calculated as the desired percentage of the loan's value, expressed in units of 1e8 */
  expectedAmountIn: string;
  /** the expected amount of collateral decrease on the loan */
  expectedCollateralWithdrawn: string;
  /** the expected amount of TOR debt decrease on the loan */
  expectedDebtRepaid: string;
  /** The number of blocks involved in the streaming swaps during the repayment process. */
  streamingSwapBlocks: number;
  /** The approximate number of seconds taken by the streaming swaps involved in the repayment process. */
  streamingSwapSeconds: number;
  /** The total expected duration for a repayment, measured in seconds, which includes the time for inbound confirmation, the duration of streaming swaps, and any outbound delays. */
  totalRepaySeconds: number;
}

export interface QuoteFees {
  /** the target asset used for all fees */
  asset: string;
  /** affiliate fee in the target asset */
  affiliate: string;
  /** outbound fee in the target asset */
  outbound: string;
  /** liquidity fees paid to pools in the target asset */
  liquidity: string;
  /** total fees in the target asset */
  total: string;
  /** the swap slippage in basis points */
  slippageBps: number;
  /** total basis points in fees relative to amount out */
  totalBps: number;
}

function createBaseQueryQuoteSwapRequest(): QueryQuoteSwapRequest {
  return {
    fromAsset: "",
    toAsset: "",
    amount: "",
    streamingInterval: "",
    streamingQuantity: "",
    destination: "",
    toleranceBps: "",
    refundAddress: "",
    affiliate: [],
    affiliateBps: [],
    height: "",
  };
}

export const QueryQuoteSwapRequest = {
  encode(
    message: QueryQuoteSwapRequest,
    writer: BinaryWriter = BinaryWriter.create()
  ): BinaryWriter {
    if (message.fromAsset !== "") {
      writer.uint32(10).string(message.fromAsset);
    }
    if (message.toAsset !== "") {
      writer.uint32(18).string(message.toAsset);
    }
    if (message.amount !== "") {
      writer.uint32(26).string(message.amount);
    }
    if (message.streamingInterval !== "") {
      writer.uint32(34).string(message.streamingInterval);
    }
    if (message.streamingQuantity !== "") {
      writer.uint32(42).string(message.streamingQuantity);
    }
    if (message.destination !== "") {
      writer.uint32(50).string(message.destination);
    }
    if (message.toleranceBps !== "") {
      writer.uint32(58).string(message.toleranceBps);
    }
    if (message.refundAddress !== "") {
      writer.uint32(66).string(message.refundAddress);
    }
    for (const v of message.affiliate) {
      writer.uint32(74).string(v!);
    }
    for (const v of message.affiliateBps) {
      writer.uint32(82).string(v!);
    }
    if (message.height !== "") {
      writer.uint32(90).string(message.height);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): QueryQuoteSwapRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryQuoteSwapRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fromAsset = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.toAsset = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.streamingInterval = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.streamingQuantity = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.destination = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.toleranceBps = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.refundAddress = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.affiliate.push(reader.string());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.affiliateBps.push(reader.string());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.height = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryQuoteSwapRequest {
    return {
      fromAsset: isSet(object.fromAsset)
        ? globalThis.String(object.fromAsset)
        : "",
      toAsset: isSet(object.toAsset) ? globalThis.String(object.toAsset) : "",
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      streamingInterval: isSet(object.streamingInterval)
        ? globalThis.String(object.streamingInterval)
        : "",
      streamingQuantity: isSet(object.streamingQuantity)
        ? globalThis.String(object.streamingQuantity)
        : "",
      destination: isSet(object.destination)
        ? globalThis.String(object.destination)
        : "",
      toleranceBps: isSet(object.toleranceBps)
        ? globalThis.String(object.toleranceBps)
        : "",
      refundAddress: isSet(object.refundAddress)
        ? globalThis.String(object.refundAddress)
        : "",
      affiliate: globalThis.Array.isArray(object?.affiliate)
        ? object.affiliate.map((e: any) => globalThis.String(e))
        : [],
      affiliateBps: globalThis.Array.isArray(object?.affiliateBps)
        ? object.affiliateBps.map((e: any) => globalThis.String(e))
        : [],
      height: isSet(object.height) ? globalThis.String(object.height) : "",
    };
  },

  toJSON(message: QueryQuoteSwapRequest): unknown {
    const obj: any = {};
    if (message.fromAsset !== "") {
      obj.fromAsset = message.fromAsset;
    }
    if (message.toAsset !== "") {
      obj.toAsset = message.toAsset;
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.streamingInterval !== "") {
      obj.streamingInterval = message.streamingInterval;
    }
    if (message.streamingQuantity !== "") {
      obj.streamingQuantity = message.streamingQuantity;
    }
    if (message.destination !== "") {
      obj.destination = message.destination;
    }
    if (message.toleranceBps !== "") {
      obj.toleranceBps = message.toleranceBps;
    }
    if (message.refundAddress !== "") {
      obj.refundAddress = message.refundAddress;
    }
    if (message.affiliate?.length) {
      obj.affiliate = message.affiliate;
    }
    if (message.affiliateBps?.length) {
      obj.affiliateBps = message.affiliateBps;
    }
    if (message.height !== "") {
      obj.height = message.height;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryQuoteSwapRequest>, I>>(
    base?: I
  ): QueryQuoteSwapRequest {
    return QueryQuoteSwapRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryQuoteSwapRequest>, I>>(
    object: I
  ): QueryQuoteSwapRequest {
    const message = createBaseQueryQuoteSwapRequest();
    message.fromAsset = object.fromAsset ?? "";
    message.toAsset = object.toAsset ?? "";
    message.amount = object.amount ?? "";
    message.streamingInterval = object.streamingInterval ?? "";
    message.streamingQuantity = object.streamingQuantity ?? "";
    message.destination = object.destination ?? "";
    message.toleranceBps = object.toleranceBps ?? "";
    message.refundAddress = object.refundAddress ?? "";
    message.affiliate = object.affiliate?.map((e) => e) || [];
    message.affiliateBps = object.affiliateBps?.map((e) => e) || [];
    message.height = object.height ?? "";
    return message;
  },
};

function createBaseQueryQuoteSwapResponse(): QueryQuoteSwapResponse {
  return {
    inboundAddress: "",
    inboundConfirmationBlocks: 0,
    inboundConfirmationSeconds: 0,
    outboundDelayBlocks: 0,
    outboundDelaySeconds: 0,
    fees: undefined,
    router: "",
    expiry: 0,
    warning: "",
    notes: "",
    dustThreshold: "",
    recommendedMinAmountIn: "",
    recommendedGasRate: "",
    gasRateUnits: "",
    memo: "",
    expectedAmountOut: "",
    maxStreamingQuantity: 0,
    streamingSwapBlocks: 0,
    streamingSwapSeconds: 0,
    totalSwapSeconds: 0,
  };
}

export const QueryQuoteSwapResponse = {
  encode(
    message: QueryQuoteSwapResponse,
    writer: BinaryWriter = BinaryWriter.create()
  ): BinaryWriter {
    if (message.inboundAddress !== "") {
      writer.uint32(10).string(message.inboundAddress);
    }
    if (message.inboundConfirmationBlocks !== 0) {
      writer.uint32(16).int64(message.inboundConfirmationBlocks);
    }
    if (message.inboundConfirmationSeconds !== 0) {
      writer.uint32(24).int64(message.inboundConfirmationSeconds);
    }
    if (message.outboundDelayBlocks !== 0) {
      writer.uint32(32).int64(message.outboundDelayBlocks);
    }
    if (message.outboundDelaySeconds !== 0) {
      writer.uint32(40).int64(message.outboundDelaySeconds);
    }
    if (message.fees !== undefined) {
      QuoteFees.encode(message.fees, writer.uint32(50).fork()).ldelim();
    }
    if (message.router !== "") {
      writer.uint32(58).string(message.router);
    }
    if (message.expiry !== 0) {
      writer.uint32(64).int64(message.expiry);
    }
    if (message.warning !== "") {
      writer.uint32(74).string(message.warning);
    }
    if (message.notes !== "") {
      writer.uint32(82).string(message.notes);
    }
    if (message.dustThreshold !== "") {
      writer.uint32(90).string(message.dustThreshold);
    }
    if (message.recommendedMinAmountIn !== "") {
      writer.uint32(98).string(message.recommendedMinAmountIn);
    }
    if (message.recommendedGasRate !== "") {
      writer.uint32(106).string(message.recommendedGasRate);
    }
    if (message.gasRateUnits !== "") {
      writer.uint32(114).string(message.gasRateUnits);
    }
    if (message.memo !== "") {
      writer.uint32(122).string(message.memo);
    }
    if (message.expectedAmountOut !== "") {
      writer.uint32(130).string(message.expectedAmountOut);
    }
    if (message.maxStreamingQuantity !== 0) {
      writer.uint32(136).int64(message.maxStreamingQuantity);
    }
    if (message.streamingSwapBlocks !== 0) {
      writer.uint32(144).int64(message.streamingSwapBlocks);
    }
    if (message.streamingSwapSeconds !== 0) {
      writer.uint32(152).int64(message.streamingSwapSeconds);
    }
    if (message.totalSwapSeconds !== 0) {
      writer.uint32(160).int64(message.totalSwapSeconds);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): QueryQuoteSwapResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryQuoteSwapResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.inboundAddress = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.inboundConfirmationBlocks = Number(reader.int64());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.inboundConfirmationSeconds = Number(reader.int64());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.outboundDelayBlocks = Number(reader.int64());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.outboundDelaySeconds = Number(reader.int64());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.fees = QuoteFees.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.router = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.expiry = Number(reader.int64());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.warning = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.notes = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.dustThreshold = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.recommendedMinAmountIn = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.recommendedGasRate = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.gasRateUnits = reader.string();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.memo = reader.string();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.expectedAmountOut = reader.string();
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.maxStreamingQuantity = Number(reader.int64());
          continue;
        case 18:
          if (tag !== 144) {
            break;
          }

          message.streamingSwapBlocks = Number(reader.int64());
          continue;
        case 19:
          if (tag !== 152) {
            break;
          }

          message.streamingSwapSeconds = Number(reader.int64());
          continue;
        case 20:
          if (tag !== 160) {
            break;
          }

          message.totalSwapSeconds = Number(reader.int64());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryQuoteSwapResponse {
    return {
      inboundAddress: isSet(object.inboundAddress)
        ? globalThis.String(object.inboundAddress)
        : "",
      inboundConfirmationBlocks: isSet(object.inboundConfirmationBlocks)
        ? globalThis.Number(object.inboundConfirmationBlocks)
        : 0,
      inboundConfirmationSeconds: isSet(object.inboundConfirmationSeconds)
        ? globalThis.Number(object.inboundConfirmationSeconds)
        : 0,
      outboundDelayBlocks: isSet(object.outboundDelayBlocks)
        ? globalThis.Number(object.outboundDelayBlocks)
        : 0,
      outboundDelaySeconds: isSet(object.outboundDelaySeconds)
        ? globalThis.Number(object.outboundDelaySeconds)
        : 0,
      fees: isSet(object.fees) ? QuoteFees.fromJSON(object.fees) : undefined,
      router: isSet(object.router) ? globalThis.String(object.router) : "",
      expiry: isSet(object.expiry) ? globalThis.Number(object.expiry) : 0,
      warning: isSet(object.warning) ? globalThis.String(object.warning) : "",
      notes: isSet(object.notes) ? globalThis.String(object.notes) : "",
      dustThreshold: isSet(object.dustThreshold)
        ? globalThis.String(object.dustThreshold)
        : "",
      recommendedMinAmountIn: isSet(object.recommendedMinAmountIn)
        ? globalThis.String(object.recommendedMinAmountIn)
        : "",
      recommendedGasRate: isSet(object.recommendedGasRate)
        ? globalThis.String(object.recommendedGasRate)
        : "",
      gasRateUnits: isSet(object.gasRateUnits)
        ? globalThis.String(object.gasRateUnits)
        : "",
      memo: isSet(object.memo) ? globalThis.String(object.memo) : "",
      expectedAmountOut: isSet(object.expectedAmountOut)
        ? globalThis.String(object.expectedAmountOut)
        : "",
      maxStreamingQuantity: isSet(object.maxStreamingQuantity)
        ? globalThis.Number(object.maxStreamingQuantity)
        : 0,
      streamingSwapBlocks: isSet(object.streamingSwapBlocks)
        ? globalThis.Number(object.streamingSwapBlocks)
        : 0,
      streamingSwapSeconds: isSet(object.streamingSwapSeconds)
        ? globalThis.Number(object.streamingSwapSeconds)
        : 0,
      totalSwapSeconds: isSet(object.totalSwapSeconds)
        ? globalThis.Number(object.totalSwapSeconds)
        : 0,
    };
  },

  toJSON(message: QueryQuoteSwapResponse): unknown {
    const obj: any = {};
    if (message.inboundAddress !== "") {
      obj.inboundAddress = message.inboundAddress;
    }
    if (message.inboundConfirmationBlocks !== 0) {
      obj.inboundConfirmationBlocks = Math.round(
        message.inboundConfirmationBlocks
      );
    }
    if (message.inboundConfirmationSeconds !== 0) {
      obj.inboundConfirmationSeconds = Math.round(
        message.inboundConfirmationSeconds
      );
    }
    if (message.outboundDelayBlocks !== 0) {
      obj.outboundDelayBlocks = Math.round(message.outboundDelayBlocks);
    }
    if (message.outboundDelaySeconds !== 0) {
      obj.outboundDelaySeconds = Math.round(message.outboundDelaySeconds);
    }
    if (message.fees !== undefined) {
      obj.fees = QuoteFees.toJSON(message.fees);
    }
    if (message.router !== "") {
      obj.router = message.router;
    }
    if (message.expiry !== 0) {
      obj.expiry = Math.round(message.expiry);
    }
    if (message.warning !== "") {
      obj.warning = message.warning;
    }
    if (message.notes !== "") {
      obj.notes = message.notes;
    }
    if (message.dustThreshold !== "") {
      obj.dustThreshold = message.dustThreshold;
    }
    if (message.recommendedMinAmountIn !== "") {
      obj.recommendedMinAmountIn = message.recommendedMinAmountIn;
    }
    if (message.recommendedGasRate !== "") {
      obj.recommendedGasRate = message.recommendedGasRate;
    }
    if (message.gasRateUnits !== "") {
      obj.gasRateUnits = message.gasRateUnits;
    }
    if (message.memo !== "") {
      obj.memo = message.memo;
    }
    if (message.expectedAmountOut !== "") {
      obj.expectedAmountOut = message.expectedAmountOut;
    }
    if (message.maxStreamingQuantity !== 0) {
      obj.maxStreamingQuantity = Math.round(message.maxStreamingQuantity);
    }
    if (message.streamingSwapBlocks !== 0) {
      obj.streamingSwapBlocks = Math.round(message.streamingSwapBlocks);
    }
    if (message.streamingSwapSeconds !== 0) {
      obj.streamingSwapSeconds = Math.round(message.streamingSwapSeconds);
    }
    if (message.totalSwapSeconds !== 0) {
      obj.totalSwapSeconds = Math.round(message.totalSwapSeconds);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryQuoteSwapResponse>, I>>(
    base?: I
  ): QueryQuoteSwapResponse {
    return QueryQuoteSwapResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryQuoteSwapResponse>, I>>(
    object: I
  ): QueryQuoteSwapResponse {
    const message = createBaseQueryQuoteSwapResponse();
    message.inboundAddress = object.inboundAddress ?? "";
    message.inboundConfirmationBlocks = object.inboundConfirmationBlocks ?? 0;
    message.inboundConfirmationSeconds = object.inboundConfirmationSeconds ?? 0;
    message.outboundDelayBlocks = object.outboundDelayBlocks ?? 0;
    message.outboundDelaySeconds = object.outboundDelaySeconds ?? 0;
    message.fees =
      object.fees !== undefined && object.fees !== null
        ? QuoteFees.fromPartial(object.fees)
        : undefined;
    message.router = object.router ?? "";
    message.expiry = object.expiry ?? 0;
    message.warning = object.warning ?? "";
    message.notes = object.notes ?? "";
    message.dustThreshold = object.dustThreshold ?? "";
    message.recommendedMinAmountIn = object.recommendedMinAmountIn ?? "";
    message.recommendedGasRate = object.recommendedGasRate ?? "";
    message.gasRateUnits = object.gasRateUnits ?? "";
    message.memo = object.memo ?? "";
    message.expectedAmountOut = object.expectedAmountOut ?? "";
    message.maxStreamingQuantity = object.maxStreamingQuantity ?? 0;
    message.streamingSwapBlocks = object.streamingSwapBlocks ?? 0;
    message.streamingSwapSeconds = object.streamingSwapSeconds ?? 0;
    message.totalSwapSeconds = object.totalSwapSeconds ?? 0;
    return message;
  },
};

function createBaseQueryQuoteSaverDepositRequest(): QueryQuoteSaverDepositRequest {
  return { asset: "", amount: "", affiliate: [], affiliateBps: [], height: "" };
}

export const QueryQuoteSaverDepositRequest = {
  encode(
    message: QueryQuoteSaverDepositRequest,
    writer: BinaryWriter = BinaryWriter.create()
  ): BinaryWriter {
    if (message.asset !== "") {
      writer.uint32(10).string(message.asset);
    }
    if (message.amount !== "") {
      writer.uint32(18).string(message.amount);
    }
    for (const v of message.affiliate) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.affiliateBps) {
      writer.uint32(34).string(v!);
    }
    if (message.height !== "") {
      writer.uint32(42).string(message.height);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): QueryQuoteSaverDepositRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryQuoteSaverDepositRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.asset = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.affiliate.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.affiliateBps.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.height = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryQuoteSaverDepositRequest {
    return {
      asset: isSet(object.asset) ? globalThis.String(object.asset) : "",
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      affiliate: globalThis.Array.isArray(object?.affiliate)
        ? object.affiliate.map((e: any) => globalThis.String(e))
        : [],
      affiliateBps: globalThis.Array.isArray(object?.affiliateBps)
        ? object.affiliateBps.map((e: any) => globalThis.String(e))
        : [],
      height: isSet(object.height) ? globalThis.String(object.height) : "",
    };
  },

  toJSON(message: QueryQuoteSaverDepositRequest): unknown {
    const obj: any = {};
    if (message.asset !== "") {
      obj.asset = message.asset;
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.affiliate?.length) {
      obj.affiliate = message.affiliate;
    }
    if (message.affiliateBps?.length) {
      obj.affiliateBps = message.affiliateBps;
    }
    if (message.height !== "") {
      obj.height = message.height;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryQuoteSaverDepositRequest>, I>>(
    base?: I
  ): QueryQuoteSaverDepositRequest {
    return QueryQuoteSaverDepositRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryQuoteSaverDepositRequest>, I>>(
    object: I
  ): QueryQuoteSaverDepositRequest {
    const message = createBaseQueryQuoteSaverDepositRequest();
    message.asset = object.asset ?? "";
    message.amount = object.amount ?? "";
    message.affiliate = object.affiliate?.map((e) => e) || [];
    message.affiliateBps = object.affiliateBps?.map((e) => e) || [];
    message.height = object.height ?? "";
    return message;
  },
};

function createBaseQueryQuoteSaverDepositResponse(): QueryQuoteSaverDepositResponse {
  return {
    inboundAddress: "",
    inboundConfirmationBlocks: 0,
    inboundConfirmationSeconds: 0,
    outboundDelayBlocks: 0,
    outboundDelaySeconds: 0,
    fees: undefined,
    router: "",
    expiry: 0,
    warning: "",
    notes: "",
    dustThreshold: "",
    recommendedMinAmountIn: "",
    recommendedGasRate: "",
    gasRateUnits: "",
    memo: "",
    expectedAmountOut: "",
    expectedAmountDeposit: "",
  };
}

export const QueryQuoteSaverDepositResponse = {
  encode(
    message: QueryQuoteSaverDepositResponse,
    writer: BinaryWriter = BinaryWriter.create()
  ): BinaryWriter {
    if (message.inboundAddress !== "") {
      writer.uint32(10).string(message.inboundAddress);
    }
    if (message.inboundConfirmationBlocks !== 0) {
      writer.uint32(16).int64(message.inboundConfirmationBlocks);
    }
    if (message.inboundConfirmationSeconds !== 0) {
      writer.uint32(24).int64(message.inboundConfirmationSeconds);
    }
    if (message.outboundDelayBlocks !== 0) {
      writer.uint32(32).int64(message.outboundDelayBlocks);
    }
    if (message.outboundDelaySeconds !== 0) {
      writer.uint32(40).int64(message.outboundDelaySeconds);
    }
    if (message.fees !== undefined) {
      QuoteFees.encode(message.fees, writer.uint32(50).fork()).ldelim();
    }
    if (message.router !== "") {
      writer.uint32(58).string(message.router);
    }
    if (message.expiry !== 0) {
      writer.uint32(64).int64(message.expiry);
    }
    if (message.warning !== "") {
      writer.uint32(74).string(message.warning);
    }
    if (message.notes !== "") {
      writer.uint32(82).string(message.notes);
    }
    if (message.dustThreshold !== "") {
      writer.uint32(90).string(message.dustThreshold);
    }
    if (message.recommendedMinAmountIn !== "") {
      writer.uint32(98).string(message.recommendedMinAmountIn);
    }
    if (message.recommendedGasRate !== "") {
      writer.uint32(106).string(message.recommendedGasRate);
    }
    if (message.gasRateUnits !== "") {
      writer.uint32(114).string(message.gasRateUnits);
    }
    if (message.memo !== "") {
      writer.uint32(122).string(message.memo);
    }
    if (message.expectedAmountOut !== "") {
      writer.uint32(130).string(message.expectedAmountOut);
    }
    if (message.expectedAmountDeposit !== "") {
      writer.uint32(138).string(message.expectedAmountDeposit);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): QueryQuoteSaverDepositResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryQuoteSaverDepositResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.inboundAddress = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.inboundConfirmationBlocks = Number(reader.int64());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.inboundConfirmationSeconds = Number(reader.int64());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.outboundDelayBlocks = Number(reader.int64());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.outboundDelaySeconds = Number(reader.int64());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.fees = QuoteFees.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.router = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.expiry = Number(reader.int64());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.warning = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.notes = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.dustThreshold = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.recommendedMinAmountIn = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.recommendedGasRate = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.gasRateUnits = reader.string();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.memo = reader.string();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.expectedAmountOut = reader.string();
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.expectedAmountDeposit = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryQuoteSaverDepositResponse {
    return {
      inboundAddress: isSet(object.inboundAddress)
        ? globalThis.String(object.inboundAddress)
        : "",
      inboundConfirmationBlocks: isSet(object.inboundConfirmationBlocks)
        ? globalThis.Number(object.inboundConfirmationBlocks)
        : 0,
      inboundConfirmationSeconds: isSet(object.inboundConfirmationSeconds)
        ? globalThis.Number(object.inboundConfirmationSeconds)
        : 0,
      outboundDelayBlocks: isSet(object.outboundDelayBlocks)
        ? globalThis.Number(object.outboundDelayBlocks)
        : 0,
      outboundDelaySeconds: isSet(object.outboundDelaySeconds)
        ? globalThis.Number(object.outboundDelaySeconds)
        : 0,
      fees: isSet(object.fees) ? QuoteFees.fromJSON(object.fees) : undefined,
      router: isSet(object.router) ? globalThis.String(object.router) : "",
      expiry: isSet(object.expiry) ? globalThis.Number(object.expiry) : 0,
      warning: isSet(object.warning) ? globalThis.String(object.warning) : "",
      notes: isSet(object.notes) ? globalThis.String(object.notes) : "",
      dustThreshold: isSet(object.dustThreshold)
        ? globalThis.String(object.dustThreshold)
        : "",
      recommendedMinAmountIn: isSet(object.recommendedMinAmountIn)
        ? globalThis.String(object.recommendedMinAmountIn)
        : "",
      recommendedGasRate: isSet(object.recommendedGasRate)
        ? globalThis.String(object.recommendedGasRate)
        : "",
      gasRateUnits: isSet(object.gasRateUnits)
        ? globalThis.String(object.gasRateUnits)
        : "",
      memo: isSet(object.memo) ? globalThis.String(object.memo) : "",
      expectedAmountOut: isSet(object.expectedAmountOut)
        ? globalThis.String(object.expectedAmountOut)
        : "",
      expectedAmountDeposit: isSet(object.expectedAmountDeposit)
        ? globalThis.String(object.expectedAmountDeposit)
        : "",
    };
  },

  toJSON(message: QueryQuoteSaverDepositResponse): unknown {
    const obj: any = {};
    if (message.inboundAddress !== "") {
      obj.inboundAddress = message.inboundAddress;
    }
    if (message.inboundConfirmationBlocks !== 0) {
      obj.inboundConfirmationBlocks = Math.round(
        message.inboundConfirmationBlocks
      );
    }
    if (message.inboundConfirmationSeconds !== 0) {
      obj.inboundConfirmationSeconds = Math.round(
        message.inboundConfirmationSeconds
      );
    }
    if (message.outboundDelayBlocks !== 0) {
      obj.outboundDelayBlocks = Math.round(message.outboundDelayBlocks);
    }
    if (message.outboundDelaySeconds !== 0) {
      obj.outboundDelaySeconds = Math.round(message.outboundDelaySeconds);
    }
    if (message.fees !== undefined) {
      obj.fees = QuoteFees.toJSON(message.fees);
    }
    if (message.router !== "") {
      obj.router = message.router;
    }
    if (message.expiry !== 0) {
      obj.expiry = Math.round(message.expiry);
    }
    if (message.warning !== "") {
      obj.warning = message.warning;
    }
    if (message.notes !== "") {
      obj.notes = message.notes;
    }
    if (message.dustThreshold !== "") {
      obj.dustThreshold = message.dustThreshold;
    }
    if (message.recommendedMinAmountIn !== "") {
      obj.recommendedMinAmountIn = message.recommendedMinAmountIn;
    }
    if (message.recommendedGasRate !== "") {
      obj.recommendedGasRate = message.recommendedGasRate;
    }
    if (message.gasRateUnits !== "") {
      obj.gasRateUnits = message.gasRateUnits;
    }
    if (message.memo !== "") {
      obj.memo = message.memo;
    }
    if (message.expectedAmountOut !== "") {
      obj.expectedAmountOut = message.expectedAmountOut;
    }
    if (message.expectedAmountDeposit !== "") {
      obj.expectedAmountDeposit = message.expectedAmountDeposit;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryQuoteSaverDepositResponse>, I>>(
    base?: I
  ): QueryQuoteSaverDepositResponse {
    return QueryQuoteSaverDepositResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryQuoteSaverDepositResponse>, I>>(
    object: I
  ): QueryQuoteSaverDepositResponse {
    const message = createBaseQueryQuoteSaverDepositResponse();
    message.inboundAddress = object.inboundAddress ?? "";
    message.inboundConfirmationBlocks = object.inboundConfirmationBlocks ?? 0;
    message.inboundConfirmationSeconds = object.inboundConfirmationSeconds ?? 0;
    message.outboundDelayBlocks = object.outboundDelayBlocks ?? 0;
    message.outboundDelaySeconds = object.outboundDelaySeconds ?? 0;
    message.fees =
      object.fees !== undefined && object.fees !== null
        ? QuoteFees.fromPartial(object.fees)
        : undefined;
    message.router = object.router ?? "";
    message.expiry = object.expiry ?? 0;
    message.warning = object.warning ?? "";
    message.notes = object.notes ?? "";
    message.dustThreshold = object.dustThreshold ?? "";
    message.recommendedMinAmountIn = object.recommendedMinAmountIn ?? "";
    message.recommendedGasRate = object.recommendedGasRate ?? "";
    message.gasRateUnits = object.gasRateUnits ?? "";
    message.memo = object.memo ?? "";
    message.expectedAmountOut = object.expectedAmountOut ?? "";
    message.expectedAmountDeposit = object.expectedAmountDeposit ?? "";
    return message;
  },
};

function createBaseQueryQuoteSaverWithdrawRequest(): QueryQuoteSaverWithdrawRequest {
  return { asset: "", address: "", withdrawBps: "", height: "" };
}

export const QueryQuoteSaverWithdrawRequest = {
  encode(
    message: QueryQuoteSaverWithdrawRequest,
    writer: BinaryWriter = BinaryWriter.create()
  ): BinaryWriter {
    if (message.asset !== "") {
      writer.uint32(10).string(message.asset);
    }
    if (message.address !== "") {
      writer.uint32(18).string(message.address);
    }
    if (message.withdrawBps !== "") {
      writer.uint32(26).string(message.withdrawBps);
    }
    if (message.height !== "") {
      writer.uint32(34).string(message.height);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): QueryQuoteSaverWithdrawRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryQuoteSaverWithdrawRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.asset = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.address = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.withdrawBps = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.height = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryQuoteSaverWithdrawRequest {
    return {
      asset: isSet(object.asset) ? globalThis.String(object.asset) : "",
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      withdrawBps: isSet(object.withdrawBps)
        ? globalThis.String(object.withdrawBps)
        : "",
      height: isSet(object.height) ? globalThis.String(object.height) : "",
    };
  },

  toJSON(message: QueryQuoteSaverWithdrawRequest): unknown {
    const obj: any = {};
    if (message.asset !== "") {
      obj.asset = message.asset;
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.withdrawBps !== "") {
      obj.withdrawBps = message.withdrawBps;
    }
    if (message.height !== "") {
      obj.height = message.height;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryQuoteSaverWithdrawRequest>, I>>(
    base?: I
  ): QueryQuoteSaverWithdrawRequest {
    return QueryQuoteSaverWithdrawRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryQuoteSaverWithdrawRequest>, I>>(
    object: I
  ): QueryQuoteSaverWithdrawRequest {
    const message = createBaseQueryQuoteSaverWithdrawRequest();
    message.asset = object.asset ?? "";
    message.address = object.address ?? "";
    message.withdrawBps = object.withdrawBps ?? "";
    message.height = object.height ?? "";
    return message;
  },
};

function createBaseQueryQuoteSaverWithdrawResponse(): QueryQuoteSaverWithdrawResponse {
  return {
    inboundAddress: "",
    inboundConfirmationBlocks: 0,
    inboundConfirmationSeconds: 0,
    outboundDelayBlocks: 0,
    outboundDelaySeconds: 0,
    fees: undefined,
    router: "",
    expiry: 0,
    warning: "",
    notes: "",
    dustThreshold: "",
    recommendedMinAmountIn: "",
    recommendedGasRate: "",
    gasRateUnits: "",
    memo: "",
    dustAmount: "",
    expectedAmountOut: "",
  };
}

export const QueryQuoteSaverWithdrawResponse = {
  encode(
    message: QueryQuoteSaverWithdrawResponse,
    writer: BinaryWriter = BinaryWriter.create()
  ): BinaryWriter {
    if (message.inboundAddress !== "") {
      writer.uint32(10).string(message.inboundAddress);
    }
    if (message.inboundConfirmationBlocks !== 0) {
      writer.uint32(16).int64(message.inboundConfirmationBlocks);
    }
    if (message.inboundConfirmationSeconds !== 0) {
      writer.uint32(24).int64(message.inboundConfirmationSeconds);
    }
    if (message.outboundDelayBlocks !== 0) {
      writer.uint32(32).int64(message.outboundDelayBlocks);
    }
    if (message.outboundDelaySeconds !== 0) {
      writer.uint32(40).int64(message.outboundDelaySeconds);
    }
    if (message.fees !== undefined) {
      QuoteFees.encode(message.fees, writer.uint32(50).fork()).ldelim();
    }
    if (message.router !== "") {
      writer.uint32(58).string(message.router);
    }
    if (message.expiry !== 0) {
      writer.uint32(64).int64(message.expiry);
    }
    if (message.warning !== "") {
      writer.uint32(74).string(message.warning);
    }
    if (message.notes !== "") {
      writer.uint32(82).string(message.notes);
    }
    if (message.dustThreshold !== "") {
      writer.uint32(90).string(message.dustThreshold);
    }
    if (message.recommendedMinAmountIn !== "") {
      writer.uint32(98).string(message.recommendedMinAmountIn);
    }
    if (message.recommendedGasRate !== "") {
      writer.uint32(106).string(message.recommendedGasRate);
    }
    if (message.gasRateUnits !== "") {
      writer.uint32(114).string(message.gasRateUnits);
    }
    if (message.memo !== "") {
      writer.uint32(122).string(message.memo);
    }
    if (message.dustAmount !== "") {
      writer.uint32(130).string(message.dustAmount);
    }
    if (message.expectedAmountOut !== "") {
      writer.uint32(138).string(message.expectedAmountOut);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): QueryQuoteSaverWithdrawResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryQuoteSaverWithdrawResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.inboundAddress = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.inboundConfirmationBlocks = Number(reader.int64());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.inboundConfirmationSeconds = Number(reader.int64());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.outboundDelayBlocks = Number(reader.int64());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.outboundDelaySeconds = Number(reader.int64());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.fees = QuoteFees.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.router = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.expiry = Number(reader.int64());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.warning = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.notes = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.dustThreshold = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.recommendedMinAmountIn = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.recommendedGasRate = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.gasRateUnits = reader.string();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.memo = reader.string();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.dustAmount = reader.string();
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.expectedAmountOut = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryQuoteSaverWithdrawResponse {
    return {
      inboundAddress: isSet(object.inboundAddress)
        ? globalThis.String(object.inboundAddress)
        : "",
      inboundConfirmationBlocks: isSet(object.inboundConfirmationBlocks)
        ? globalThis.Number(object.inboundConfirmationBlocks)
        : 0,
      inboundConfirmationSeconds: isSet(object.inboundConfirmationSeconds)
        ? globalThis.Number(object.inboundConfirmationSeconds)
        : 0,
      outboundDelayBlocks: isSet(object.outboundDelayBlocks)
        ? globalThis.Number(object.outboundDelayBlocks)
        : 0,
      outboundDelaySeconds: isSet(object.outboundDelaySeconds)
        ? globalThis.Number(object.outboundDelaySeconds)
        : 0,
      fees: isSet(object.fees) ? QuoteFees.fromJSON(object.fees) : undefined,
      router: isSet(object.router) ? globalThis.String(object.router) : "",
      expiry: isSet(object.expiry) ? globalThis.Number(object.expiry) : 0,
      warning: isSet(object.warning) ? globalThis.String(object.warning) : "",
      notes: isSet(object.notes) ? globalThis.String(object.notes) : "",
      dustThreshold: isSet(object.dustThreshold)
        ? globalThis.String(object.dustThreshold)
        : "",
      recommendedMinAmountIn: isSet(object.recommendedMinAmountIn)
        ? globalThis.String(object.recommendedMinAmountIn)
        : "",
      recommendedGasRate: isSet(object.recommendedGasRate)
        ? globalThis.String(object.recommendedGasRate)
        : "",
      gasRateUnits: isSet(object.gasRateUnits)
        ? globalThis.String(object.gasRateUnits)
        : "",
      memo: isSet(object.memo) ? globalThis.String(object.memo) : "",
      dustAmount: isSet(object.dustAmount)
        ? globalThis.String(object.dustAmount)
        : "",
      expectedAmountOut: isSet(object.expectedAmountOut)
        ? globalThis.String(object.expectedAmountOut)
        : "",
    };
  },

  toJSON(message: QueryQuoteSaverWithdrawResponse): unknown {
    const obj: any = {};
    if (message.inboundAddress !== "") {
      obj.inboundAddress = message.inboundAddress;
    }
    if (message.inboundConfirmationBlocks !== 0) {
      obj.inboundConfirmationBlocks = Math.round(
        message.inboundConfirmationBlocks
      );
    }
    if (message.inboundConfirmationSeconds !== 0) {
      obj.inboundConfirmationSeconds = Math.round(
        message.inboundConfirmationSeconds
      );
    }
    if (message.outboundDelayBlocks !== 0) {
      obj.outboundDelayBlocks = Math.round(message.outboundDelayBlocks);
    }
    if (message.outboundDelaySeconds !== 0) {
      obj.outboundDelaySeconds = Math.round(message.outboundDelaySeconds);
    }
    if (message.fees !== undefined) {
      obj.fees = QuoteFees.toJSON(message.fees);
    }
    if (message.router !== "") {
      obj.router = message.router;
    }
    if (message.expiry !== 0) {
      obj.expiry = Math.round(message.expiry);
    }
    if (message.warning !== "") {
      obj.warning = message.warning;
    }
    if (message.notes !== "") {
      obj.notes = message.notes;
    }
    if (message.dustThreshold !== "") {
      obj.dustThreshold = message.dustThreshold;
    }
    if (message.recommendedMinAmountIn !== "") {
      obj.recommendedMinAmountIn = message.recommendedMinAmountIn;
    }
    if (message.recommendedGasRate !== "") {
      obj.recommendedGasRate = message.recommendedGasRate;
    }
    if (message.gasRateUnits !== "") {
      obj.gasRateUnits = message.gasRateUnits;
    }
    if (message.memo !== "") {
      obj.memo = message.memo;
    }
    if (message.dustAmount !== "") {
      obj.dustAmount = message.dustAmount;
    }
    if (message.expectedAmountOut !== "") {
      obj.expectedAmountOut = message.expectedAmountOut;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryQuoteSaverWithdrawResponse>, I>>(
    base?: I
  ): QueryQuoteSaverWithdrawResponse {
    return QueryQuoteSaverWithdrawResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryQuoteSaverWithdrawResponse>, I>>(
    object: I
  ): QueryQuoteSaverWithdrawResponse {
    const message = createBaseQueryQuoteSaverWithdrawResponse();
    message.inboundAddress = object.inboundAddress ?? "";
    message.inboundConfirmationBlocks = object.inboundConfirmationBlocks ?? 0;
    message.inboundConfirmationSeconds = object.inboundConfirmationSeconds ?? 0;
    message.outboundDelayBlocks = object.outboundDelayBlocks ?? 0;
    message.outboundDelaySeconds = object.outboundDelaySeconds ?? 0;
    message.fees =
      object.fees !== undefined && object.fees !== null
        ? QuoteFees.fromPartial(object.fees)
        : undefined;
    message.router = object.router ?? "";
    message.expiry = object.expiry ?? 0;
    message.warning = object.warning ?? "";
    message.notes = object.notes ?? "";
    message.dustThreshold = object.dustThreshold ?? "";
    message.recommendedMinAmountIn = object.recommendedMinAmountIn ?? "";
    message.recommendedGasRate = object.recommendedGasRate ?? "";
    message.gasRateUnits = object.gasRateUnits ?? "";
    message.memo = object.memo ?? "";
    message.dustAmount = object.dustAmount ?? "";
    message.expectedAmountOut = object.expectedAmountOut ?? "";
    return message;
  },
};

function createBaseQueryQuoteLoanOpenRequest(): QueryQuoteLoanOpenRequest {
  return {
    fromAsset: "",
    toAsset: "",
    amount: "",
    minOut: "",
    destination: "",
    affiliate: [],
    affiliateBps: [],
    height: "",
  };
}

export const QueryQuoteLoanOpenRequest = {
  encode(
    message: QueryQuoteLoanOpenRequest,
    writer: BinaryWriter = BinaryWriter.create()
  ): BinaryWriter {
    if (message.fromAsset !== "") {
      writer.uint32(10).string(message.fromAsset);
    }
    if (message.toAsset !== "") {
      writer.uint32(18).string(message.toAsset);
    }
    if (message.amount !== "") {
      writer.uint32(26).string(message.amount);
    }
    if (message.minOut !== "") {
      writer.uint32(34).string(message.minOut);
    }
    if (message.destination !== "") {
      writer.uint32(42).string(message.destination);
    }
    for (const v of message.affiliate) {
      writer.uint32(50).string(v!);
    }
    for (const v of message.affiliateBps) {
      writer.uint32(58).string(v!);
    }
    if (message.height !== "") {
      writer.uint32(66).string(message.height);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): QueryQuoteLoanOpenRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryQuoteLoanOpenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fromAsset = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.toAsset = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.minOut = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.destination = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.affiliate.push(reader.string());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.affiliateBps.push(reader.string());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.height = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryQuoteLoanOpenRequest {
    return {
      fromAsset: isSet(object.fromAsset)
        ? globalThis.String(object.fromAsset)
        : "",
      toAsset: isSet(object.toAsset) ? globalThis.String(object.toAsset) : "",
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      minOut: isSet(object.minOut) ? globalThis.String(object.minOut) : "",
      destination: isSet(object.destination)
        ? globalThis.String(object.destination)
        : "",
      affiliate: globalThis.Array.isArray(object?.affiliate)
        ? object.affiliate.map((e: any) => globalThis.String(e))
        : [],
      affiliateBps: globalThis.Array.isArray(object?.affiliateBps)
        ? object.affiliateBps.map((e: any) => globalThis.String(e))
        : [],
      height: isSet(object.height) ? globalThis.String(object.height) : "",
    };
  },

  toJSON(message: QueryQuoteLoanOpenRequest): unknown {
    const obj: any = {};
    if (message.fromAsset !== "") {
      obj.fromAsset = message.fromAsset;
    }
    if (message.toAsset !== "") {
      obj.toAsset = message.toAsset;
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.minOut !== "") {
      obj.minOut = message.minOut;
    }
    if (message.destination !== "") {
      obj.destination = message.destination;
    }
    if (message.affiliate?.length) {
      obj.affiliate = message.affiliate;
    }
    if (message.affiliateBps?.length) {
      obj.affiliateBps = message.affiliateBps;
    }
    if (message.height !== "") {
      obj.height = message.height;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryQuoteLoanOpenRequest>, I>>(
    base?: I
  ): QueryQuoteLoanOpenRequest {
    return QueryQuoteLoanOpenRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryQuoteLoanOpenRequest>, I>>(
    object: I
  ): QueryQuoteLoanOpenRequest {
    const message = createBaseQueryQuoteLoanOpenRequest();
    message.fromAsset = object.fromAsset ?? "";
    message.toAsset = object.toAsset ?? "";
    message.amount = object.amount ?? "";
    message.minOut = object.minOut ?? "";
    message.destination = object.destination ?? "";
    message.affiliate = object.affiliate?.map((e) => e) || [];
    message.affiliateBps = object.affiliateBps?.map((e) => e) || [];
    message.height = object.height ?? "";
    return message;
  },
};

function createBaseQueryQuoteLoanOpenResponse(): QueryQuoteLoanOpenResponse {
  return {
    inboundAddress: "",
    inboundConfirmationBlocks: 0,
    inboundConfirmationSeconds: 0,
    outboundDelayBlocks: 0,
    outboundDelaySeconds: 0,
    fees: undefined,
    router: "",
    expiry: 0,
    warning: "",
    notes: "",
    dustThreshold: "",
    recommendedMinAmountIn: "",
    recommendedGasRate: "",
    gasRateUnits: "",
    memo: "",
    expectedAmountOut: "",
    expectedCollateralizationRatio: "",
    expectedCollateralDeposited: "",
    expectedDebtIssued: "",
    streamingSwapBlocks: 0,
    streamingSwapSeconds: 0,
    totalOpenLoanSeconds: 0,
  };
}

export const QueryQuoteLoanOpenResponse = {
  encode(
    message: QueryQuoteLoanOpenResponse,
    writer: BinaryWriter = BinaryWriter.create()
  ): BinaryWriter {
    if (message.inboundAddress !== "") {
      writer.uint32(10).string(message.inboundAddress);
    }
    if (message.inboundConfirmationBlocks !== 0) {
      writer.uint32(16).int64(message.inboundConfirmationBlocks);
    }
    if (message.inboundConfirmationSeconds !== 0) {
      writer.uint32(24).int64(message.inboundConfirmationSeconds);
    }
    if (message.outboundDelayBlocks !== 0) {
      writer.uint32(32).int64(message.outboundDelayBlocks);
    }
    if (message.outboundDelaySeconds !== 0) {
      writer.uint32(40).int64(message.outboundDelaySeconds);
    }
    if (message.fees !== undefined) {
      QuoteFees.encode(message.fees, writer.uint32(50).fork()).ldelim();
    }
    if (message.router !== "") {
      writer.uint32(58).string(message.router);
    }
    if (message.expiry !== 0) {
      writer.uint32(64).int64(message.expiry);
    }
    if (message.warning !== "") {
      writer.uint32(74).string(message.warning);
    }
    if (message.notes !== "") {
      writer.uint32(82).string(message.notes);
    }
    if (message.dustThreshold !== "") {
      writer.uint32(90).string(message.dustThreshold);
    }
    if (message.recommendedMinAmountIn !== "") {
      writer.uint32(98).string(message.recommendedMinAmountIn);
    }
    if (message.recommendedGasRate !== "") {
      writer.uint32(106).string(message.recommendedGasRate);
    }
    if (message.gasRateUnits !== "") {
      writer.uint32(114).string(message.gasRateUnits);
    }
    if (message.memo !== "") {
      writer.uint32(122).string(message.memo);
    }
    if (message.expectedAmountOut !== "") {
      writer.uint32(130).string(message.expectedAmountOut);
    }
    if (message.expectedCollateralizationRatio !== "") {
      writer.uint32(138).string(message.expectedCollateralizationRatio);
    }
    if (message.expectedCollateralDeposited !== "") {
      writer.uint32(146).string(message.expectedCollateralDeposited);
    }
    if (message.expectedDebtIssued !== "") {
      writer.uint32(154).string(message.expectedDebtIssued);
    }
    if (message.streamingSwapBlocks !== 0) {
      writer.uint32(160).int64(message.streamingSwapBlocks);
    }
    if (message.streamingSwapSeconds !== 0) {
      writer.uint32(168).int64(message.streamingSwapSeconds);
    }
    if (message.totalOpenLoanSeconds !== 0) {
      writer.uint32(176).int64(message.totalOpenLoanSeconds);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): QueryQuoteLoanOpenResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryQuoteLoanOpenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.inboundAddress = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.inboundConfirmationBlocks = Number(reader.int64());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.inboundConfirmationSeconds = Number(reader.int64());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.outboundDelayBlocks = Number(reader.int64());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.outboundDelaySeconds = Number(reader.int64());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.fees = QuoteFees.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.router = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.expiry = Number(reader.int64());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.warning = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.notes = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.dustThreshold = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.recommendedMinAmountIn = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.recommendedGasRate = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.gasRateUnits = reader.string();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.memo = reader.string();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.expectedAmountOut = reader.string();
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.expectedCollateralizationRatio = reader.string();
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.expectedCollateralDeposited = reader.string();
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.expectedDebtIssued = reader.string();
          continue;
        case 20:
          if (tag !== 160) {
            break;
          }

          message.streamingSwapBlocks = Number(reader.int64());
          continue;
        case 21:
          if (tag !== 168) {
            break;
          }

          message.streamingSwapSeconds = Number(reader.int64());
          continue;
        case 22:
          if (tag !== 176) {
            break;
          }

          message.totalOpenLoanSeconds = Number(reader.int64());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryQuoteLoanOpenResponse {
    return {
      inboundAddress: isSet(object.inboundAddress)
        ? globalThis.String(object.inboundAddress)
        : "",
      inboundConfirmationBlocks: isSet(object.inboundConfirmationBlocks)
        ? globalThis.Number(object.inboundConfirmationBlocks)
        : 0,
      inboundConfirmationSeconds: isSet(object.inboundConfirmationSeconds)
        ? globalThis.Number(object.inboundConfirmationSeconds)
        : 0,
      outboundDelayBlocks: isSet(object.outboundDelayBlocks)
        ? globalThis.Number(object.outboundDelayBlocks)
        : 0,
      outboundDelaySeconds: isSet(object.outboundDelaySeconds)
        ? globalThis.Number(object.outboundDelaySeconds)
        : 0,
      fees: isSet(object.fees) ? QuoteFees.fromJSON(object.fees) : undefined,
      router: isSet(object.router) ? globalThis.String(object.router) : "",
      expiry: isSet(object.expiry) ? globalThis.Number(object.expiry) : 0,
      warning: isSet(object.warning) ? globalThis.String(object.warning) : "",
      notes: isSet(object.notes) ? globalThis.String(object.notes) : "",
      dustThreshold: isSet(object.dustThreshold)
        ? globalThis.String(object.dustThreshold)
        : "",
      recommendedMinAmountIn: isSet(object.recommendedMinAmountIn)
        ? globalThis.String(object.recommendedMinAmountIn)
        : "",
      recommendedGasRate: isSet(object.recommendedGasRate)
        ? globalThis.String(object.recommendedGasRate)
        : "",
      gasRateUnits: isSet(object.gasRateUnits)
        ? globalThis.String(object.gasRateUnits)
        : "",
      memo: isSet(object.memo) ? globalThis.String(object.memo) : "",
      expectedAmountOut: isSet(object.expectedAmountOut)
        ? globalThis.String(object.expectedAmountOut)
        : "",
      expectedCollateralizationRatio: isSet(
        object.expectedCollateralizationRatio
      )
        ? globalThis.String(object.expectedCollateralizationRatio)
        : "",
      expectedCollateralDeposited: isSet(object.expectedCollateralDeposited)
        ? globalThis.String(object.expectedCollateralDeposited)
        : "",
      expectedDebtIssued: isSet(object.expectedDebtIssued)
        ? globalThis.String(object.expectedDebtIssued)
        : "",
      streamingSwapBlocks: isSet(object.streamingSwapBlocks)
        ? globalThis.Number(object.streamingSwapBlocks)
        : 0,
      streamingSwapSeconds: isSet(object.streamingSwapSeconds)
        ? globalThis.Number(object.streamingSwapSeconds)
        : 0,
      totalOpenLoanSeconds: isSet(object.totalOpenLoanSeconds)
        ? globalThis.Number(object.totalOpenLoanSeconds)
        : 0,
    };
  },

  toJSON(message: QueryQuoteLoanOpenResponse): unknown {
    const obj: any = {};
    if (message.inboundAddress !== "") {
      obj.inboundAddress = message.inboundAddress;
    }
    if (message.inboundConfirmationBlocks !== 0) {
      obj.inboundConfirmationBlocks = Math.round(
        message.inboundConfirmationBlocks
      );
    }
    if (message.inboundConfirmationSeconds !== 0) {
      obj.inboundConfirmationSeconds = Math.round(
        message.inboundConfirmationSeconds
      );
    }
    if (message.outboundDelayBlocks !== 0) {
      obj.outboundDelayBlocks = Math.round(message.outboundDelayBlocks);
    }
    if (message.outboundDelaySeconds !== 0) {
      obj.outboundDelaySeconds = Math.round(message.outboundDelaySeconds);
    }
    if (message.fees !== undefined) {
      obj.fees = QuoteFees.toJSON(message.fees);
    }
    if (message.router !== "") {
      obj.router = message.router;
    }
    if (message.expiry !== 0) {
      obj.expiry = Math.round(message.expiry);
    }
    if (message.warning !== "") {
      obj.warning = message.warning;
    }
    if (message.notes !== "") {
      obj.notes = message.notes;
    }
    if (message.dustThreshold !== "") {
      obj.dustThreshold = message.dustThreshold;
    }
    if (message.recommendedMinAmountIn !== "") {
      obj.recommendedMinAmountIn = message.recommendedMinAmountIn;
    }
    if (message.recommendedGasRate !== "") {
      obj.recommendedGasRate = message.recommendedGasRate;
    }
    if (message.gasRateUnits !== "") {
      obj.gasRateUnits = message.gasRateUnits;
    }
    if (message.memo !== "") {
      obj.memo = message.memo;
    }
    if (message.expectedAmountOut !== "") {
      obj.expectedAmountOut = message.expectedAmountOut;
    }
    if (message.expectedCollateralizationRatio !== "") {
      obj.expectedCollateralizationRatio =
        message.expectedCollateralizationRatio;
    }
    if (message.expectedCollateralDeposited !== "") {
      obj.expectedCollateralDeposited = message.expectedCollateralDeposited;
    }
    if (message.expectedDebtIssued !== "") {
      obj.expectedDebtIssued = message.expectedDebtIssued;
    }
    if (message.streamingSwapBlocks !== 0) {
      obj.streamingSwapBlocks = Math.round(message.streamingSwapBlocks);
    }
    if (message.streamingSwapSeconds !== 0) {
      obj.streamingSwapSeconds = Math.round(message.streamingSwapSeconds);
    }
    if (message.totalOpenLoanSeconds !== 0) {
      obj.totalOpenLoanSeconds = Math.round(message.totalOpenLoanSeconds);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryQuoteLoanOpenResponse>, I>>(
    base?: I
  ): QueryQuoteLoanOpenResponse {
    return QueryQuoteLoanOpenResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryQuoteLoanOpenResponse>, I>>(
    object: I
  ): QueryQuoteLoanOpenResponse {
    const message = createBaseQueryQuoteLoanOpenResponse();
    message.inboundAddress = object.inboundAddress ?? "";
    message.inboundConfirmationBlocks = object.inboundConfirmationBlocks ?? 0;
    message.inboundConfirmationSeconds = object.inboundConfirmationSeconds ?? 0;
    message.outboundDelayBlocks = object.outboundDelayBlocks ?? 0;
    message.outboundDelaySeconds = object.outboundDelaySeconds ?? 0;
    message.fees =
      object.fees !== undefined && object.fees !== null
        ? QuoteFees.fromPartial(object.fees)
        : undefined;
    message.router = object.router ?? "";
    message.expiry = object.expiry ?? 0;
    message.warning = object.warning ?? "";
    message.notes = object.notes ?? "";
    message.dustThreshold = object.dustThreshold ?? "";
    message.recommendedMinAmountIn = object.recommendedMinAmountIn ?? "";
    message.recommendedGasRate = object.recommendedGasRate ?? "";
    message.gasRateUnits = object.gasRateUnits ?? "";
    message.memo = object.memo ?? "";
    message.expectedAmountOut = object.expectedAmountOut ?? "";
    message.expectedCollateralizationRatio =
      object.expectedCollateralizationRatio ?? "";
    message.expectedCollateralDeposited =
      object.expectedCollateralDeposited ?? "";
    message.expectedDebtIssued = object.expectedDebtIssued ?? "";
    message.streamingSwapBlocks = object.streamingSwapBlocks ?? 0;
    message.streamingSwapSeconds = object.streamingSwapSeconds ?? 0;
    message.totalOpenLoanSeconds = object.totalOpenLoanSeconds ?? 0;
    return message;
  },
};

function createBaseQueryQuoteLoanCloseRequest(): QueryQuoteLoanCloseRequest {
  return {
    fromAsset: "",
    toAsset: "",
    minOut: "",
    repayBps: "",
    loanOwner: "",
    height: "",
  };
}

export const QueryQuoteLoanCloseRequest = {
  encode(
    message: QueryQuoteLoanCloseRequest,
    writer: BinaryWriter = BinaryWriter.create()
  ): BinaryWriter {
    if (message.fromAsset !== "") {
      writer.uint32(10).string(message.fromAsset);
    }
    if (message.toAsset !== "") {
      writer.uint32(18).string(message.toAsset);
    }
    if (message.minOut !== "") {
      writer.uint32(26).string(message.minOut);
    }
    if (message.repayBps !== "") {
      writer.uint32(34).string(message.repayBps);
    }
    if (message.loanOwner !== "") {
      writer.uint32(42).string(message.loanOwner);
    }
    if (message.height !== "") {
      writer.uint32(50).string(message.height);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): QueryQuoteLoanCloseRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryQuoteLoanCloseRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fromAsset = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.toAsset = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.minOut = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.repayBps = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.loanOwner = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.height = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryQuoteLoanCloseRequest {
    return {
      fromAsset: isSet(object.fromAsset)
        ? globalThis.String(object.fromAsset)
        : "",
      toAsset: isSet(object.toAsset) ? globalThis.String(object.toAsset) : "",
      minOut: isSet(object.minOut) ? globalThis.String(object.minOut) : "",
      repayBps: isSet(object.repayBps)
        ? globalThis.String(object.repayBps)
        : "",
      loanOwner: isSet(object.loanOwner)
        ? globalThis.String(object.loanOwner)
        : "",
      height: isSet(object.height) ? globalThis.String(object.height) : "",
    };
  },

  toJSON(message: QueryQuoteLoanCloseRequest): unknown {
    const obj: any = {};
    if (message.fromAsset !== "") {
      obj.fromAsset = message.fromAsset;
    }
    if (message.toAsset !== "") {
      obj.toAsset = message.toAsset;
    }
    if (message.minOut !== "") {
      obj.minOut = message.minOut;
    }
    if (message.repayBps !== "") {
      obj.repayBps = message.repayBps;
    }
    if (message.loanOwner !== "") {
      obj.loanOwner = message.loanOwner;
    }
    if (message.height !== "") {
      obj.height = message.height;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryQuoteLoanCloseRequest>, I>>(
    base?: I
  ): QueryQuoteLoanCloseRequest {
    return QueryQuoteLoanCloseRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryQuoteLoanCloseRequest>, I>>(
    object: I
  ): QueryQuoteLoanCloseRequest {
    const message = createBaseQueryQuoteLoanCloseRequest();
    message.fromAsset = object.fromAsset ?? "";
    message.toAsset = object.toAsset ?? "";
    message.minOut = object.minOut ?? "";
    message.repayBps = object.repayBps ?? "";
    message.loanOwner = object.loanOwner ?? "";
    message.height = object.height ?? "";
    return message;
  },
};

function createBaseQueryQuoteLoanCloseResponse(): QueryQuoteLoanCloseResponse {
  return {
    inboundAddress: "",
    inboundConfirmationBlocks: 0,
    inboundConfirmationSeconds: 0,
    outboundDelayBlocks: 0,
    outboundDelaySeconds: 0,
    fees: undefined,
    router: "",
    expiry: 0,
    warning: "",
    notes: "",
    dustThreshold: "",
    recommendedMinAmountIn: "",
    recommendedGasRate: "",
    gasRateUnits: "",
    memo: "",
    expectedAmountOut: "",
    expectedAmountIn: "",
    expectedCollateralWithdrawn: "",
    expectedDebtRepaid: "",
    streamingSwapBlocks: 0,
    streamingSwapSeconds: 0,
    totalRepaySeconds: 0,
  };
}

export const QueryQuoteLoanCloseResponse = {
  encode(
    message: QueryQuoteLoanCloseResponse,
    writer: BinaryWriter = BinaryWriter.create()
  ): BinaryWriter {
    if (message.inboundAddress !== "") {
      writer.uint32(10).string(message.inboundAddress);
    }
    if (message.inboundConfirmationBlocks !== 0) {
      writer.uint32(16).int64(message.inboundConfirmationBlocks);
    }
    if (message.inboundConfirmationSeconds !== 0) {
      writer.uint32(24).int64(message.inboundConfirmationSeconds);
    }
    if (message.outboundDelayBlocks !== 0) {
      writer.uint32(32).int64(message.outboundDelayBlocks);
    }
    if (message.outboundDelaySeconds !== 0) {
      writer.uint32(40).int64(message.outboundDelaySeconds);
    }
    if (message.fees !== undefined) {
      QuoteFees.encode(message.fees, writer.uint32(50).fork()).ldelim();
    }
    if (message.router !== "") {
      writer.uint32(58).string(message.router);
    }
    if (message.expiry !== 0) {
      writer.uint32(64).int64(message.expiry);
    }
    if (message.warning !== "") {
      writer.uint32(74).string(message.warning);
    }
    if (message.notes !== "") {
      writer.uint32(82).string(message.notes);
    }
    if (message.dustThreshold !== "") {
      writer.uint32(90).string(message.dustThreshold);
    }
    if (message.recommendedMinAmountIn !== "") {
      writer.uint32(98).string(message.recommendedMinAmountIn);
    }
    if (message.recommendedGasRate !== "") {
      writer.uint32(106).string(message.recommendedGasRate);
    }
    if (message.gasRateUnits !== "") {
      writer.uint32(114).string(message.gasRateUnits);
    }
    if (message.memo !== "") {
      writer.uint32(122).string(message.memo);
    }
    if (message.expectedAmountOut !== "") {
      writer.uint32(130).string(message.expectedAmountOut);
    }
    if (message.expectedAmountIn !== "") {
      writer.uint32(138).string(message.expectedAmountIn);
    }
    if (message.expectedCollateralWithdrawn !== "") {
      writer.uint32(146).string(message.expectedCollateralWithdrawn);
    }
    if (message.expectedDebtRepaid !== "") {
      writer.uint32(154).string(message.expectedDebtRepaid);
    }
    if (message.streamingSwapBlocks !== 0) {
      writer.uint32(160).int64(message.streamingSwapBlocks);
    }
    if (message.streamingSwapSeconds !== 0) {
      writer.uint32(168).int64(message.streamingSwapSeconds);
    }
    if (message.totalRepaySeconds !== 0) {
      writer.uint32(176).int64(message.totalRepaySeconds);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): QueryQuoteLoanCloseResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryQuoteLoanCloseResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.inboundAddress = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.inboundConfirmationBlocks = Number(reader.int64());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.inboundConfirmationSeconds = Number(reader.int64());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.outboundDelayBlocks = Number(reader.int64());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.outboundDelaySeconds = Number(reader.int64());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.fees = QuoteFees.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.router = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.expiry = Number(reader.int64());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.warning = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.notes = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.dustThreshold = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.recommendedMinAmountIn = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.recommendedGasRate = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.gasRateUnits = reader.string();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.memo = reader.string();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.expectedAmountOut = reader.string();
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.expectedAmountIn = reader.string();
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.expectedCollateralWithdrawn = reader.string();
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.expectedDebtRepaid = reader.string();
          continue;
        case 20:
          if (tag !== 160) {
            break;
          }

          message.streamingSwapBlocks = Number(reader.int64());
          continue;
        case 21:
          if (tag !== 168) {
            break;
          }

          message.streamingSwapSeconds = Number(reader.int64());
          continue;
        case 22:
          if (tag !== 176) {
            break;
          }

          message.totalRepaySeconds = Number(reader.int64());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryQuoteLoanCloseResponse {
    return {
      inboundAddress: isSet(object.inboundAddress)
        ? globalThis.String(object.inboundAddress)
        : "",
      inboundConfirmationBlocks: isSet(object.inboundConfirmationBlocks)
        ? globalThis.Number(object.inboundConfirmationBlocks)
        : 0,
      inboundConfirmationSeconds: isSet(object.inboundConfirmationSeconds)
        ? globalThis.Number(object.inboundConfirmationSeconds)
        : 0,
      outboundDelayBlocks: isSet(object.outboundDelayBlocks)
        ? globalThis.Number(object.outboundDelayBlocks)
        : 0,
      outboundDelaySeconds: isSet(object.outboundDelaySeconds)
        ? globalThis.Number(object.outboundDelaySeconds)
        : 0,
      fees: isSet(object.fees) ? QuoteFees.fromJSON(object.fees) : undefined,
      router: isSet(object.router) ? globalThis.String(object.router) : "",
      expiry: isSet(object.expiry) ? globalThis.Number(object.expiry) : 0,
      warning: isSet(object.warning) ? globalThis.String(object.warning) : "",
      notes: isSet(object.notes) ? globalThis.String(object.notes) : "",
      dustThreshold: isSet(object.dustThreshold)
        ? globalThis.String(object.dustThreshold)
        : "",
      recommendedMinAmountIn: isSet(object.recommendedMinAmountIn)
        ? globalThis.String(object.recommendedMinAmountIn)
        : "",
      recommendedGasRate: isSet(object.recommendedGasRate)
        ? globalThis.String(object.recommendedGasRate)
        : "",
      gasRateUnits: isSet(object.gasRateUnits)
        ? globalThis.String(object.gasRateUnits)
        : "",
      memo: isSet(object.memo) ? globalThis.String(object.memo) : "",
      expectedAmountOut: isSet(object.expectedAmountOut)
        ? globalThis.String(object.expectedAmountOut)
        : "",
      expectedAmountIn: isSet(object.expectedAmountIn)
        ? globalThis.String(object.expectedAmountIn)
        : "",
      expectedCollateralWithdrawn: isSet(object.expectedCollateralWithdrawn)
        ? globalThis.String(object.expectedCollateralWithdrawn)
        : "",
      expectedDebtRepaid: isSet(object.expectedDebtRepaid)
        ? globalThis.String(object.expectedDebtRepaid)
        : "",
      streamingSwapBlocks: isSet(object.streamingSwapBlocks)
        ? globalThis.Number(object.streamingSwapBlocks)
        : 0,
      streamingSwapSeconds: isSet(object.streamingSwapSeconds)
        ? globalThis.Number(object.streamingSwapSeconds)
        : 0,
      totalRepaySeconds: isSet(object.totalRepaySeconds)
        ? globalThis.Number(object.totalRepaySeconds)
        : 0,
    };
  },

  toJSON(message: QueryQuoteLoanCloseResponse): unknown {
    const obj: any = {};
    if (message.inboundAddress !== "") {
      obj.inboundAddress = message.inboundAddress;
    }
    if (message.inboundConfirmationBlocks !== 0) {
      obj.inboundConfirmationBlocks = Math.round(
        message.inboundConfirmationBlocks
      );
    }
    if (message.inboundConfirmationSeconds !== 0) {
      obj.inboundConfirmationSeconds = Math.round(
        message.inboundConfirmationSeconds
      );
    }
    if (message.outboundDelayBlocks !== 0) {
      obj.outboundDelayBlocks = Math.round(message.outboundDelayBlocks);
    }
    if (message.outboundDelaySeconds !== 0) {
      obj.outboundDelaySeconds = Math.round(message.outboundDelaySeconds);
    }
    if (message.fees !== undefined) {
      obj.fees = QuoteFees.toJSON(message.fees);
    }
    if (message.router !== "") {
      obj.router = message.router;
    }
    if (message.expiry !== 0) {
      obj.expiry = Math.round(message.expiry);
    }
    if (message.warning !== "") {
      obj.warning = message.warning;
    }
    if (message.notes !== "") {
      obj.notes = message.notes;
    }
    if (message.dustThreshold !== "") {
      obj.dustThreshold = message.dustThreshold;
    }
    if (message.recommendedMinAmountIn !== "") {
      obj.recommendedMinAmountIn = message.recommendedMinAmountIn;
    }
    if (message.recommendedGasRate !== "") {
      obj.recommendedGasRate = message.recommendedGasRate;
    }
    if (message.gasRateUnits !== "") {
      obj.gasRateUnits = message.gasRateUnits;
    }
    if (message.memo !== "") {
      obj.memo = message.memo;
    }
    if (message.expectedAmountOut !== "") {
      obj.expectedAmountOut = message.expectedAmountOut;
    }
    if (message.expectedAmountIn !== "") {
      obj.expectedAmountIn = message.expectedAmountIn;
    }
    if (message.expectedCollateralWithdrawn !== "") {
      obj.expectedCollateralWithdrawn = message.expectedCollateralWithdrawn;
    }
    if (message.expectedDebtRepaid !== "") {
      obj.expectedDebtRepaid = message.expectedDebtRepaid;
    }
    if (message.streamingSwapBlocks !== 0) {
      obj.streamingSwapBlocks = Math.round(message.streamingSwapBlocks);
    }
    if (message.streamingSwapSeconds !== 0) {
      obj.streamingSwapSeconds = Math.round(message.streamingSwapSeconds);
    }
    if (message.totalRepaySeconds !== 0) {
      obj.totalRepaySeconds = Math.round(message.totalRepaySeconds);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryQuoteLoanCloseResponse>, I>>(
    base?: I
  ): QueryQuoteLoanCloseResponse {
    return QueryQuoteLoanCloseResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryQuoteLoanCloseResponse>, I>>(
    object: I
  ): QueryQuoteLoanCloseResponse {
    const message = createBaseQueryQuoteLoanCloseResponse();
    message.inboundAddress = object.inboundAddress ?? "";
    message.inboundConfirmationBlocks = object.inboundConfirmationBlocks ?? 0;
    message.inboundConfirmationSeconds = object.inboundConfirmationSeconds ?? 0;
    message.outboundDelayBlocks = object.outboundDelayBlocks ?? 0;
    message.outboundDelaySeconds = object.outboundDelaySeconds ?? 0;
    message.fees =
      object.fees !== undefined && object.fees !== null
        ? QuoteFees.fromPartial(object.fees)
        : undefined;
    message.router = object.router ?? "";
    message.expiry = object.expiry ?? 0;
    message.warning = object.warning ?? "";
    message.notes = object.notes ?? "";
    message.dustThreshold = object.dustThreshold ?? "";
    message.recommendedMinAmountIn = object.recommendedMinAmountIn ?? "";
    message.recommendedGasRate = object.recommendedGasRate ?? "";
    message.gasRateUnits = object.gasRateUnits ?? "";
    message.memo = object.memo ?? "";
    message.expectedAmountOut = object.expectedAmountOut ?? "";
    message.expectedAmountIn = object.expectedAmountIn ?? "";
    message.expectedCollateralWithdrawn =
      object.expectedCollateralWithdrawn ?? "";
    message.expectedDebtRepaid = object.expectedDebtRepaid ?? "";
    message.streamingSwapBlocks = object.streamingSwapBlocks ?? 0;
    message.streamingSwapSeconds = object.streamingSwapSeconds ?? 0;
    message.totalRepaySeconds = object.totalRepaySeconds ?? 0;
    return message;
  },
};

function createBaseQuoteFees(): QuoteFees {
  return {
    asset: "",
    affiliate: "",
    outbound: "",
    liquidity: "",
    total: "",
    slippageBps: 0,
    totalBps: 0,
  };
}

export const QuoteFees = {
  encode(
    message: QuoteFees,
    writer: BinaryWriter = BinaryWriter.create()
  ): BinaryWriter {
    if (message.asset !== "") {
      writer.uint32(10).string(message.asset);
    }
    if (message.affiliate !== "") {
      writer.uint32(18).string(message.affiliate);
    }
    if (message.outbound !== "") {
      writer.uint32(26).string(message.outbound);
    }
    if (message.liquidity !== "") {
      writer.uint32(34).string(message.liquidity);
    }
    if (message.total !== "") {
      writer.uint32(42).string(message.total);
    }
    if (message.slippageBps !== 0) {
      writer.uint32(48).int64(message.slippageBps);
    }
    if (message.totalBps !== 0) {
      writer.uint32(56).int64(message.totalBps);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QuoteFees {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuoteFees();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.asset = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.affiliate = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.outbound = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.liquidity = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.total = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.slippageBps = Number(reader.int64());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.totalBps = Number(reader.int64());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuoteFees {
    return {
      asset: isSet(object.asset) ? globalThis.String(object.asset) : "",
      affiliate: isSet(object.affiliate)
        ? globalThis.String(object.affiliate)
        : "",
      outbound: isSet(object.outbound)
        ? globalThis.String(object.outbound)
        : "",
      liquidity: isSet(object.liquidity)
        ? globalThis.String(object.liquidity)
        : "",
      total: isSet(object.total) ? globalThis.String(object.total) : "",
      slippageBps: isSet(object.slippageBps)
        ? globalThis.Number(object.slippageBps)
        : 0,
      totalBps: isSet(object.totalBps) ? globalThis.Number(object.totalBps) : 0,
    };
  },

  toJSON(message: QuoteFees): unknown {
    const obj: any = {};
    if (message.asset !== "") {
      obj.asset = message.asset;
    }
    if (message.affiliate !== "") {
      obj.affiliate = message.affiliate;
    }
    if (message.outbound !== "") {
      obj.outbound = message.outbound;
    }
    if (message.liquidity !== "") {
      obj.liquidity = message.liquidity;
    }
    if (message.total !== "") {
      obj.total = message.total;
    }
    if (message.slippageBps !== 0) {
      obj.slippageBps = Math.round(message.slippageBps);
    }
    if (message.totalBps !== 0) {
      obj.totalBps = Math.round(message.totalBps);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QuoteFees>, I>>(base?: I): QuoteFees {
    return QuoteFees.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QuoteFees>, I>>(
    object: I
  ): QuoteFees {
    const message = createBaseQuoteFees();
    message.asset = object.asset ?? "";
    message.affiliate = object.affiliate ?? "";
    message.outbound = object.outbound ?? "";
    message.liquidity = object.liquidity ?? "";
    message.total = object.total ?? "";
    message.slippageBps = object.slippageBps ?? 0;
    message.totalBps = object.totalBps ?? 0;
    return message;
  },
};
