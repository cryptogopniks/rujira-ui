// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               unknown
// source: types/query_tx.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "../../binary";
import { DeepPartial, Exact, isSet } from "../../helpers";
import { Coin, Tx } from "../common/common";
import { ProtoInt64 } from "./misc";
import { TssKeysignMetric } from "./type_tss_metric";
import { TxOutItem } from "./type_tx_out";

export const protobufPackage = "types";

export interface QueryTxStagesRequest {
  txId: string;
  height: string;
}

export interface QueryTxStagesResponse {
  inboundObserved: InboundObservedStage | undefined;
  inboundConfirmationCounted: InboundConfirmationCountedStage | undefined;
  inboundFinalised: InboundFinalisedStage | undefined;
  swapStatus: SwapStatus | undefined;
  swapFinalised: SwapFinalisedStage | undefined;
  outboundDelay: OutboundDelayStage | undefined;
  outboundSigned: OutboundSignedStage | undefined;
}

export interface QueryTxStatusRequest {
  txId: string;
  height: string;
}

export interface QueryTxStatusResponse {
  tx: Tx | undefined;
  plannedOutTxs: PlannedOutTx[];
  outTxs: Tx[];
  stages: QueryTxStagesResponse | undefined;
}

export interface QueryTxRequest {
  txId: string;
  height: string;
}

export interface QueryTxResponse {
  observedTx: QueryObservedTx | undefined;
  /** the thorchain height at which the inbound reached consensus */
  consensusHeight: number;
  /** the thorchain height at which the outbound was finalised */
  finalisedHeight: number;
  /** the thorchain height for which the outbound was scheduled */
  outboundHeight: number;
  keysignMetric: TssKeysignMetric | undefined;
}

/** Same as ObservedTx, but changes block_height and finalise_height (openapi spec) */
export interface QueryObservedTx {
  tx: Tx | undefined;
  status: string;
  outHashes: string[];
  blockHeight: number;
  signers: string[];
  observedPubKey: string;
  keysignMs: number;
  finaliseHeight: number;
  aggregator: string;
  aggregatorTarget: string;
  aggregatorTargetLimit: string;
}

/** Same as ObservedTxVoter, but changes height (openapi spec) */
export interface QueryObservedTxVoter {
  txId: string;
  tx: QueryObservedTx | undefined;
  height: number;
  txs: QueryObservedTx[];
  actions: TxOutItem[];
  outTxs: Tx[];
  finalisedHeight: number;
  updatedVault: boolean;
  reverted: boolean;
  outboundHeight: number;
}

export interface QueryTxVotersRequest {
  txId: string;
  height: string;
}

export interface PlannedOutTx {
  chain: string;
  toAddress: string;
  coin: Coin | undefined;
  /** returns true if the planned transaction has a refund memo */
  refund: boolean;
}

export interface InboundObservedStage {
  /** returns true if any nodes have observed the transaction (to be deprecated in favour of counts) */
  started: boolean;
  /** number of signers for pre-confirmation-counting observations */
  preConfirmationCount: number;
  /** number of signers for final observations, after any confirmation counting complete */
  finalCount: number;
  /** returns true if no transaction observation remains to be done */
  completed: boolean;
}

export interface InboundConfirmationCountedStage {
  /** the THORChain block height when confirmation counting began */
  countingStartHeight: number;
  /** the external source chain for which confirmation counting takes place */
  chain: string;
  /** the block height on the external source chain when the transaction was observed */
  externalObservedHeight: number;
  /** the block height on the external source chain when confirmation counting will be complete */
  externalConfirmationDelayHeight: number;
  /** the estimated remaining seconds before confirmation counting completes */
  remainingConfirmationSeconds: number;
  /** returns true if no transaction confirmation counting remains to be done */
  completed: boolean;
}

export interface InboundFinalisedStage {
  /** returns true if the inbound transaction has been finalised (THORChain agreeing it exists) */
  completed: boolean;
}

export interface SwapStatus {
  /** true when awaiting a swap */
  pending: boolean;
  streaming: StreamingStatus | undefined;
}

export interface StreamingStatus {
  /** how often each swap is made, in blocks */
  interval: number;
  /** the total number of swaps in a streaming swaps */
  quantity: number;
  /** the amount of swap attempts so far */
  count: number;
}

export interface SwapFinalisedStage {
  /** (to be deprecated in favor of swap_status) returns true if an inbound transaction's swap (successful or refunded) is no longer pending */
  completed: boolean;
}

export interface OutboundDelayStage {
  /** the number of remaining THORChain blocks the outbound will be delayed */
  remainingDelayBlocks: number;
  /** the estimated remaining seconds of the outbound delay before it will be sent */
  remainingDelaySeconds: number;
  /** returns true if no transaction outbound delay remains */
  completed: boolean;
}

export interface OutboundSignedStage {
  /** THORChain height for which the external outbound is scheduled */
  scheduledOutboundHeight: number;
  /** THORChain blocks since the scheduled outbound height */
  blocksSinceScheduled: ProtoInt64 | undefined;
  /** returns true if an external transaction has been signed and broadcast (and observed in its mempool) */
  completed: boolean;
}

function createBaseQueryTxStagesRequest(): QueryTxStagesRequest {
  return { txId: "", height: "" };
}

export const QueryTxStagesRequest = {
  encode(
    message: QueryTxStagesRequest,
    writer: BinaryWriter = BinaryWriter.create()
  ): BinaryWriter {
    if (message.txId !== "") {
      writer.uint32(10).string(message.txId);
    }
    if (message.height !== "") {
      writer.uint32(18).string(message.height);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): QueryTxStagesRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryTxStagesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.txId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.height = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryTxStagesRequest {
    return {
      txId: isSet(object.txId) ? globalThis.String(object.txId) : "",
      height: isSet(object.height) ? globalThis.String(object.height) : "",
    };
  },

  toJSON(message: QueryTxStagesRequest): unknown {
    const obj: any = {};
    if (message.txId !== "") {
      obj.txId = message.txId;
    }
    if (message.height !== "") {
      obj.height = message.height;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryTxStagesRequest>, I>>(
    base?: I
  ): QueryTxStagesRequest {
    return QueryTxStagesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryTxStagesRequest>, I>>(
    object: I
  ): QueryTxStagesRequest {
    const message = createBaseQueryTxStagesRequest();
    message.txId = object.txId ?? "";
    message.height = object.height ?? "";
    return message;
  },
};

function createBaseQueryTxStagesResponse(): QueryTxStagesResponse {
  return {
    inboundObserved: undefined,
    inboundConfirmationCounted: undefined,
    inboundFinalised: undefined,
    swapStatus: undefined,
    swapFinalised: undefined,
    outboundDelay: undefined,
    outboundSigned: undefined,
  };
}

export const QueryTxStagesResponse = {
  encode(
    message: QueryTxStagesResponse,
    writer: BinaryWriter = BinaryWriter.create()
  ): BinaryWriter {
    if (message.inboundObserved !== undefined) {
      InboundObservedStage.encode(
        message.inboundObserved,
        writer.uint32(10).fork()
      ).ldelim();
    }
    if (message.inboundConfirmationCounted !== undefined) {
      InboundConfirmationCountedStage.encode(
        message.inboundConfirmationCounted,
        writer.uint32(18).fork()
      ).ldelim();
    }
    if (message.inboundFinalised !== undefined) {
      InboundFinalisedStage.encode(
        message.inboundFinalised,
        writer.uint32(26).fork()
      ).ldelim();
    }
    if (message.swapStatus !== undefined) {
      SwapStatus.encode(message.swapStatus, writer.uint32(34).fork()).ldelim();
    }
    if (message.swapFinalised !== undefined) {
      SwapFinalisedStage.encode(
        message.swapFinalised,
        writer.uint32(42).fork()
      ).ldelim();
    }
    if (message.outboundDelay !== undefined) {
      OutboundDelayStage.encode(
        message.outboundDelay,
        writer.uint32(50).fork()
      ).ldelim();
    }
    if (message.outboundSigned !== undefined) {
      OutboundSignedStage.encode(
        message.outboundSigned,
        writer.uint32(58).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): QueryTxStagesResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryTxStagesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.inboundObserved = InboundObservedStage.decode(
            reader,
            reader.uint32()
          );
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.inboundConfirmationCounted =
            InboundConfirmationCountedStage.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.inboundFinalised = InboundFinalisedStage.decode(
            reader,
            reader.uint32()
          );
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.swapStatus = SwapStatus.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.swapFinalised = SwapFinalisedStage.decode(
            reader,
            reader.uint32()
          );
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.outboundDelay = OutboundDelayStage.decode(
            reader,
            reader.uint32()
          );
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.outboundSigned = OutboundSignedStage.decode(
            reader,
            reader.uint32()
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryTxStagesResponse {
    return {
      inboundObserved: isSet(object.inboundObserved)
        ? InboundObservedStage.fromJSON(object.inboundObserved)
        : undefined,
      inboundConfirmationCounted: isSet(object.inboundConfirmationCounted)
        ? InboundConfirmationCountedStage.fromJSON(
            object.inboundConfirmationCounted
          )
        : undefined,
      inboundFinalised: isSet(object.inboundFinalised)
        ? InboundFinalisedStage.fromJSON(object.inboundFinalised)
        : undefined,
      swapStatus: isSet(object.swapStatus)
        ? SwapStatus.fromJSON(object.swapStatus)
        : undefined,
      swapFinalised: isSet(object.swapFinalised)
        ? SwapFinalisedStage.fromJSON(object.swapFinalised)
        : undefined,
      outboundDelay: isSet(object.outboundDelay)
        ? OutboundDelayStage.fromJSON(object.outboundDelay)
        : undefined,
      outboundSigned: isSet(object.outboundSigned)
        ? OutboundSignedStage.fromJSON(object.outboundSigned)
        : undefined,
    };
  },

  toJSON(message: QueryTxStagesResponse): unknown {
    const obj: any = {};
    if (message.inboundObserved !== undefined) {
      obj.inboundObserved = InboundObservedStage.toJSON(
        message.inboundObserved
      );
    }
    if (message.inboundConfirmationCounted !== undefined) {
      obj.inboundConfirmationCounted = InboundConfirmationCountedStage.toJSON(
        message.inboundConfirmationCounted
      );
    }
    if (message.inboundFinalised !== undefined) {
      obj.inboundFinalised = InboundFinalisedStage.toJSON(
        message.inboundFinalised
      );
    }
    if (message.swapStatus !== undefined) {
      obj.swapStatus = SwapStatus.toJSON(message.swapStatus);
    }
    if (message.swapFinalised !== undefined) {
      obj.swapFinalised = SwapFinalisedStage.toJSON(message.swapFinalised);
    }
    if (message.outboundDelay !== undefined) {
      obj.outboundDelay = OutboundDelayStage.toJSON(message.outboundDelay);
    }
    if (message.outboundSigned !== undefined) {
      obj.outboundSigned = OutboundSignedStage.toJSON(message.outboundSigned);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryTxStagesResponse>, I>>(
    base?: I
  ): QueryTxStagesResponse {
    return QueryTxStagesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryTxStagesResponse>, I>>(
    object: I
  ): QueryTxStagesResponse {
    const message = createBaseQueryTxStagesResponse();
    message.inboundObserved =
      object.inboundObserved !== undefined && object.inboundObserved !== null
        ? InboundObservedStage.fromPartial(object.inboundObserved)
        : undefined;
    message.inboundConfirmationCounted =
      object.inboundConfirmationCounted !== undefined &&
      object.inboundConfirmationCounted !== null
        ? InboundConfirmationCountedStage.fromPartial(
            object.inboundConfirmationCounted
          )
        : undefined;
    message.inboundFinalised =
      object.inboundFinalised !== undefined && object.inboundFinalised !== null
        ? InboundFinalisedStage.fromPartial(object.inboundFinalised)
        : undefined;
    message.swapStatus =
      object.swapStatus !== undefined && object.swapStatus !== null
        ? SwapStatus.fromPartial(object.swapStatus)
        : undefined;
    message.swapFinalised =
      object.swapFinalised !== undefined && object.swapFinalised !== null
        ? SwapFinalisedStage.fromPartial(object.swapFinalised)
        : undefined;
    message.outboundDelay =
      object.outboundDelay !== undefined && object.outboundDelay !== null
        ? OutboundDelayStage.fromPartial(object.outboundDelay)
        : undefined;
    message.outboundSigned =
      object.outboundSigned !== undefined && object.outboundSigned !== null
        ? OutboundSignedStage.fromPartial(object.outboundSigned)
        : undefined;
    return message;
  },
};

function createBaseQueryTxStatusRequest(): QueryTxStatusRequest {
  return { txId: "", height: "" };
}

export const QueryTxStatusRequest = {
  encode(
    message: QueryTxStatusRequest,
    writer: BinaryWriter = BinaryWriter.create()
  ): BinaryWriter {
    if (message.txId !== "") {
      writer.uint32(10).string(message.txId);
    }
    if (message.height !== "") {
      writer.uint32(18).string(message.height);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): QueryTxStatusRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryTxStatusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.txId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.height = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryTxStatusRequest {
    return {
      txId: isSet(object.txId) ? globalThis.String(object.txId) : "",
      height: isSet(object.height) ? globalThis.String(object.height) : "",
    };
  },

  toJSON(message: QueryTxStatusRequest): unknown {
    const obj: any = {};
    if (message.txId !== "") {
      obj.txId = message.txId;
    }
    if (message.height !== "") {
      obj.height = message.height;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryTxStatusRequest>, I>>(
    base?: I
  ): QueryTxStatusRequest {
    return QueryTxStatusRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryTxStatusRequest>, I>>(
    object: I
  ): QueryTxStatusRequest {
    const message = createBaseQueryTxStatusRequest();
    message.txId = object.txId ?? "";
    message.height = object.height ?? "";
    return message;
  },
};

function createBaseQueryTxStatusResponse(): QueryTxStatusResponse {
  return { tx: undefined, plannedOutTxs: [], outTxs: [], stages: undefined };
}

export const QueryTxStatusResponse = {
  encode(
    message: QueryTxStatusResponse,
    writer: BinaryWriter = BinaryWriter.create()
  ): BinaryWriter {
    if (message.tx !== undefined) {
      Tx.encode(message.tx, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.plannedOutTxs) {
      PlannedOutTx.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.outTxs) {
      Tx.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message.stages !== undefined) {
      QueryTxStagesResponse.encode(
        message.stages,
        writer.uint32(34).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): QueryTxStatusResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryTxStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tx = Tx.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.plannedOutTxs.push(
            PlannedOutTx.decode(reader, reader.uint32())
          );
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.outTxs.push(Tx.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.stages = QueryTxStagesResponse.decode(
            reader,
            reader.uint32()
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryTxStatusResponse {
    return {
      tx: isSet(object.tx) ? Tx.fromJSON(object.tx) : undefined,
      plannedOutTxs: globalThis.Array.isArray(object?.plannedOutTxs)
        ? object.plannedOutTxs.map((e: any) => PlannedOutTx.fromJSON(e))
        : [],
      outTxs: globalThis.Array.isArray(object?.outTxs)
        ? object.outTxs.map((e: any) => Tx.fromJSON(e))
        : [],
      stages: isSet(object.stages)
        ? QueryTxStagesResponse.fromJSON(object.stages)
        : undefined,
    };
  },

  toJSON(message: QueryTxStatusResponse): unknown {
    const obj: any = {};
    if (message.tx !== undefined) {
      obj.tx = Tx.toJSON(message.tx);
    }
    if (message.plannedOutTxs?.length) {
      obj.plannedOutTxs = message.plannedOutTxs.map((e) =>
        PlannedOutTx.toJSON(e)
      );
    }
    if (message.outTxs?.length) {
      obj.outTxs = message.outTxs.map((e) => Tx.toJSON(e));
    }
    if (message.stages !== undefined) {
      obj.stages = QueryTxStagesResponse.toJSON(message.stages);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryTxStatusResponse>, I>>(
    base?: I
  ): QueryTxStatusResponse {
    return QueryTxStatusResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryTxStatusResponse>, I>>(
    object: I
  ): QueryTxStatusResponse {
    const message = createBaseQueryTxStatusResponse();
    message.tx =
      object.tx !== undefined && object.tx !== null
        ? Tx.fromPartial(object.tx)
        : undefined;
    message.plannedOutTxs =
      object.plannedOutTxs?.map((e) => PlannedOutTx.fromPartial(e)) || [];
    message.outTxs = object.outTxs?.map((e) => Tx.fromPartial(e)) || [];
    message.stages =
      object.stages !== undefined && object.stages !== null
        ? QueryTxStagesResponse.fromPartial(object.stages)
        : undefined;
    return message;
  },
};

function createBaseQueryTxRequest(): QueryTxRequest {
  return { txId: "", height: "" };
}

export const QueryTxRequest = {
  encode(
    message: QueryTxRequest,
    writer: BinaryWriter = BinaryWriter.create()
  ): BinaryWriter {
    if (message.txId !== "") {
      writer.uint32(10).string(message.txId);
    }
    if (message.height !== "") {
      writer.uint32(18).string(message.height);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryTxRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryTxRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.txId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.height = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryTxRequest {
    return {
      txId: isSet(object.txId) ? globalThis.String(object.txId) : "",
      height: isSet(object.height) ? globalThis.String(object.height) : "",
    };
  },

  toJSON(message: QueryTxRequest): unknown {
    const obj: any = {};
    if (message.txId !== "") {
      obj.txId = message.txId;
    }
    if (message.height !== "") {
      obj.height = message.height;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryTxRequest>, I>>(
    base?: I
  ): QueryTxRequest {
    return QueryTxRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryTxRequest>, I>>(
    object: I
  ): QueryTxRequest {
    const message = createBaseQueryTxRequest();
    message.txId = object.txId ?? "";
    message.height = object.height ?? "";
    return message;
  },
};

function createBaseQueryTxResponse(): QueryTxResponse {
  return {
    observedTx: undefined,
    consensusHeight: 0,
    finalisedHeight: 0,
    outboundHeight: 0,
    keysignMetric: undefined,
  };
}

export const QueryTxResponse = {
  encode(
    message: QueryTxResponse,
    writer: BinaryWriter = BinaryWriter.create()
  ): BinaryWriter {
    if (message.observedTx !== undefined) {
      QueryObservedTx.encode(
        message.observedTx,
        writer.uint32(10).fork()
      ).ldelim();
    }
    if (message.consensusHeight !== 0) {
      writer.uint32(16).int64(message.consensusHeight);
    }
    if (message.finalisedHeight !== 0) {
      writer.uint32(24).int64(message.finalisedHeight);
    }
    if (message.outboundHeight !== 0) {
      writer.uint32(32).int64(message.outboundHeight);
    }
    if (message.keysignMetric !== undefined) {
      TssKeysignMetric.encode(
        message.keysignMetric,
        writer.uint32(42).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryTxResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryTxResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.observedTx = QueryObservedTx.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.consensusHeight = Number(reader.int64());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.finalisedHeight = Number(reader.int64());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.outboundHeight = Number(reader.int64());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.keysignMetric = TssKeysignMetric.decode(
            reader,
            reader.uint32()
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryTxResponse {
    return {
      observedTx: isSet(object.observedTx)
        ? QueryObservedTx.fromJSON(object.observedTx)
        : undefined,
      consensusHeight: isSet(object.consensusHeight)
        ? globalThis.Number(object.consensusHeight)
        : 0,
      finalisedHeight: isSet(object.finalisedHeight)
        ? globalThis.Number(object.finalisedHeight)
        : 0,
      outboundHeight: isSet(object.outboundHeight)
        ? globalThis.Number(object.outboundHeight)
        : 0,
      keysignMetric: isSet(object.keysignMetric)
        ? TssKeysignMetric.fromJSON(object.keysignMetric)
        : undefined,
    };
  },

  toJSON(message: QueryTxResponse): unknown {
    const obj: any = {};
    if (message.observedTx !== undefined) {
      obj.observedTx = QueryObservedTx.toJSON(message.observedTx);
    }
    if (message.consensusHeight !== 0) {
      obj.consensusHeight = Math.round(message.consensusHeight);
    }
    if (message.finalisedHeight !== 0) {
      obj.finalisedHeight = Math.round(message.finalisedHeight);
    }
    if (message.outboundHeight !== 0) {
      obj.outboundHeight = Math.round(message.outboundHeight);
    }
    if (message.keysignMetric !== undefined) {
      obj.keysignMetric = TssKeysignMetric.toJSON(message.keysignMetric);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryTxResponse>, I>>(
    base?: I
  ): QueryTxResponse {
    return QueryTxResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryTxResponse>, I>>(
    object: I
  ): QueryTxResponse {
    const message = createBaseQueryTxResponse();
    message.observedTx =
      object.observedTx !== undefined && object.observedTx !== null
        ? QueryObservedTx.fromPartial(object.observedTx)
        : undefined;
    message.consensusHeight = object.consensusHeight ?? 0;
    message.finalisedHeight = object.finalisedHeight ?? 0;
    message.outboundHeight = object.outboundHeight ?? 0;
    message.keysignMetric =
      object.keysignMetric !== undefined && object.keysignMetric !== null
        ? TssKeysignMetric.fromPartial(object.keysignMetric)
        : undefined;
    return message;
  },
};

function createBaseQueryObservedTx(): QueryObservedTx {
  return {
    tx: undefined,
    status: "",
    outHashes: [],
    blockHeight: 0,
    signers: [],
    observedPubKey: "",
    keysignMs: 0,
    finaliseHeight: 0,
    aggregator: "",
    aggregatorTarget: "",
    aggregatorTargetLimit: "",
  };
}

export const QueryObservedTx = {
  encode(
    message: QueryObservedTx,
    writer: BinaryWriter = BinaryWriter.create()
  ): BinaryWriter {
    if (message.tx !== undefined) {
      Tx.encode(message.tx, writer.uint32(10).fork()).ldelim();
    }
    if (message.status !== "") {
      writer.uint32(18).string(message.status);
    }
    for (const v of message.outHashes) {
      writer.uint32(26).string(v!);
    }
    if (message.blockHeight !== 0) {
      writer.uint32(32).int64(message.blockHeight);
    }
    for (const v of message.signers) {
      writer.uint32(42).string(v!);
    }
    if (message.observedPubKey !== "") {
      writer.uint32(50).string(message.observedPubKey);
    }
    if (message.keysignMs !== 0) {
      writer.uint32(56).int64(message.keysignMs);
    }
    if (message.finaliseHeight !== 0) {
      writer.uint32(64).int64(message.finaliseHeight);
    }
    if (message.aggregator !== "") {
      writer.uint32(74).string(message.aggregator);
    }
    if (message.aggregatorTarget !== "") {
      writer.uint32(82).string(message.aggregatorTarget);
    }
    if (message.aggregatorTargetLimit !== "") {
      writer.uint32(90).string(message.aggregatorTargetLimit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryObservedTx {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryObservedTx();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tx = Tx.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.status = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.outHashes.push(reader.string());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.blockHeight = Number(reader.int64());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.signers.push(reader.string());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.observedPubKey = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.keysignMs = Number(reader.int64());
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.finaliseHeight = Number(reader.int64());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.aggregator = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.aggregatorTarget = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.aggregatorTargetLimit = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryObservedTx {
    return {
      tx: isSet(object.tx) ? Tx.fromJSON(object.tx) : undefined,
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      outHashes: globalThis.Array.isArray(object?.outHashes)
        ? object.outHashes.map((e: any) => globalThis.String(e))
        : [],
      blockHeight: isSet(object.blockHeight)
        ? globalThis.Number(object.blockHeight)
        : 0,
      signers: globalThis.Array.isArray(object?.signers)
        ? object.signers.map((e: any) => globalThis.String(e))
        : [],
      observedPubKey: isSet(object.observedPubKey)
        ? globalThis.String(object.observedPubKey)
        : "",
      keysignMs: isSet(object.keysignMs)
        ? globalThis.Number(object.keysignMs)
        : 0,
      finaliseHeight: isSet(object.finaliseHeight)
        ? globalThis.Number(object.finaliseHeight)
        : 0,
      aggregator: isSet(object.aggregator)
        ? globalThis.String(object.aggregator)
        : "",
      aggregatorTarget: isSet(object.aggregatorTarget)
        ? globalThis.String(object.aggregatorTarget)
        : "",
      aggregatorTargetLimit: isSet(object.aggregatorTargetLimit)
        ? globalThis.String(object.aggregatorTargetLimit)
        : "",
    };
  },

  toJSON(message: QueryObservedTx): unknown {
    const obj: any = {};
    if (message.tx !== undefined) {
      obj.tx = Tx.toJSON(message.tx);
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.outHashes?.length) {
      obj.outHashes = message.outHashes;
    }
    if (message.blockHeight !== 0) {
      obj.blockHeight = Math.round(message.blockHeight);
    }
    if (message.signers?.length) {
      obj.signers = message.signers;
    }
    if (message.observedPubKey !== "") {
      obj.observedPubKey = message.observedPubKey;
    }
    if (message.keysignMs !== 0) {
      obj.keysignMs = Math.round(message.keysignMs);
    }
    if (message.finaliseHeight !== 0) {
      obj.finaliseHeight = Math.round(message.finaliseHeight);
    }
    if (message.aggregator !== "") {
      obj.aggregator = message.aggregator;
    }
    if (message.aggregatorTarget !== "") {
      obj.aggregatorTarget = message.aggregatorTarget;
    }
    if (message.aggregatorTargetLimit !== "") {
      obj.aggregatorTargetLimit = message.aggregatorTargetLimit;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryObservedTx>, I>>(
    base?: I
  ): QueryObservedTx {
    return QueryObservedTx.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryObservedTx>, I>>(
    object: I
  ): QueryObservedTx {
    const message = createBaseQueryObservedTx();
    message.tx =
      object.tx !== undefined && object.tx !== null
        ? Tx.fromPartial(object.tx)
        : undefined;
    message.status = object.status ?? "";
    message.outHashes = object.outHashes?.map((e) => e) || [];
    message.blockHeight = object.blockHeight ?? 0;
    message.signers = object.signers?.map((e) => e) || [];
    message.observedPubKey = object.observedPubKey ?? "";
    message.keysignMs = object.keysignMs ?? 0;
    message.finaliseHeight = object.finaliseHeight ?? 0;
    message.aggregator = object.aggregator ?? "";
    message.aggregatorTarget = object.aggregatorTarget ?? "";
    message.aggregatorTargetLimit = object.aggregatorTargetLimit ?? "";
    return message;
  },
};

function createBaseQueryObservedTxVoter(): QueryObservedTxVoter {
  return {
    txId: "",
    tx: undefined,
    height: 0,
    txs: [],
    actions: [],
    outTxs: [],
    finalisedHeight: 0,
    updatedVault: false,
    reverted: false,
    outboundHeight: 0,
  };
}

export const QueryObservedTxVoter = {
  encode(
    message: QueryObservedTxVoter,
    writer: BinaryWriter = BinaryWriter.create()
  ): BinaryWriter {
    if (message.txId !== "") {
      writer.uint32(10).string(message.txId);
    }
    if (message.tx !== undefined) {
      QueryObservedTx.encode(message.tx, writer.uint32(18).fork()).ldelim();
    }
    if (message.height !== 0) {
      writer.uint32(24).int64(message.height);
    }
    for (const v of message.txs) {
      QueryObservedTx.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.actions) {
      TxOutItem.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    for (const v of message.outTxs) {
      Tx.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    if (message.finalisedHeight !== 0) {
      writer.uint32(56).int64(message.finalisedHeight);
    }
    if (message.updatedVault !== false) {
      writer.uint32(64).bool(message.updatedVault);
    }
    if (message.reverted !== false) {
      writer.uint32(72).bool(message.reverted);
    }
    if (message.outboundHeight !== 0) {
      writer.uint32(80).int64(message.outboundHeight);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): QueryObservedTxVoter {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryObservedTxVoter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.txId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.tx = QueryObservedTx.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.height = Number(reader.int64());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.txs.push(QueryObservedTx.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.actions.push(TxOutItem.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.outTxs.push(Tx.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.finalisedHeight = Number(reader.int64());
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.updatedVault = reader.bool();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.reverted = reader.bool();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.outboundHeight = Number(reader.int64());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryObservedTxVoter {
    return {
      txId: isSet(object.txId) ? globalThis.String(object.txId) : "",
      tx: isSet(object.tx) ? QueryObservedTx.fromJSON(object.tx) : undefined,
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
      txs: globalThis.Array.isArray(object?.txs)
        ? object.txs.map((e: any) => QueryObservedTx.fromJSON(e))
        : [],
      actions: globalThis.Array.isArray(object?.actions)
        ? object.actions.map((e: any) => TxOutItem.fromJSON(e))
        : [],
      outTxs: globalThis.Array.isArray(object?.outTxs)
        ? object.outTxs.map((e: any) => Tx.fromJSON(e))
        : [],
      finalisedHeight: isSet(object.finalisedHeight)
        ? globalThis.Number(object.finalisedHeight)
        : 0,
      updatedVault: isSet(object.updatedVault)
        ? globalThis.Boolean(object.updatedVault)
        : false,
      reverted: isSet(object.reverted)
        ? globalThis.Boolean(object.reverted)
        : false,
      outboundHeight: isSet(object.outboundHeight)
        ? globalThis.Number(object.outboundHeight)
        : 0,
    };
  },

  toJSON(message: QueryObservedTxVoter): unknown {
    const obj: any = {};
    if (message.txId !== "") {
      obj.txId = message.txId;
    }
    if (message.tx !== undefined) {
      obj.tx = QueryObservedTx.toJSON(message.tx);
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    if (message.txs?.length) {
      obj.txs = message.txs.map((e) => QueryObservedTx.toJSON(e));
    }
    if (message.actions?.length) {
      obj.actions = message.actions.map((e) => TxOutItem.toJSON(e));
    }
    if (message.outTxs?.length) {
      obj.outTxs = message.outTxs.map((e) => Tx.toJSON(e));
    }
    if (message.finalisedHeight !== 0) {
      obj.finalisedHeight = Math.round(message.finalisedHeight);
    }
    if (message.updatedVault !== false) {
      obj.updatedVault = message.updatedVault;
    }
    if (message.reverted !== false) {
      obj.reverted = message.reverted;
    }
    if (message.outboundHeight !== 0) {
      obj.outboundHeight = Math.round(message.outboundHeight);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryObservedTxVoter>, I>>(
    base?: I
  ): QueryObservedTxVoter {
    return QueryObservedTxVoter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryObservedTxVoter>, I>>(
    object: I
  ): QueryObservedTxVoter {
    const message = createBaseQueryObservedTxVoter();
    message.txId = object.txId ?? "";
    message.tx =
      object.tx !== undefined && object.tx !== null
        ? QueryObservedTx.fromPartial(object.tx)
        : undefined;
    message.height = object.height ?? 0;
    message.txs = object.txs?.map((e) => QueryObservedTx.fromPartial(e)) || [];
    message.actions =
      object.actions?.map((e) => TxOutItem.fromPartial(e)) || [];
    message.outTxs = object.outTxs?.map((e) => Tx.fromPartial(e)) || [];
    message.finalisedHeight = object.finalisedHeight ?? 0;
    message.updatedVault = object.updatedVault ?? false;
    message.reverted = object.reverted ?? false;
    message.outboundHeight = object.outboundHeight ?? 0;
    return message;
  },
};

function createBaseQueryTxVotersRequest(): QueryTxVotersRequest {
  return { txId: "", height: "" };
}

export const QueryTxVotersRequest = {
  encode(
    message: QueryTxVotersRequest,
    writer: BinaryWriter = BinaryWriter.create()
  ): BinaryWriter {
    if (message.txId !== "") {
      writer.uint32(10).string(message.txId);
    }
    if (message.height !== "") {
      writer.uint32(18).string(message.height);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): QueryTxVotersRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryTxVotersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.txId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.height = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryTxVotersRequest {
    return {
      txId: isSet(object.txId) ? globalThis.String(object.txId) : "",
      height: isSet(object.height) ? globalThis.String(object.height) : "",
    };
  },

  toJSON(message: QueryTxVotersRequest): unknown {
    const obj: any = {};
    if (message.txId !== "") {
      obj.txId = message.txId;
    }
    if (message.height !== "") {
      obj.height = message.height;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryTxVotersRequest>, I>>(
    base?: I
  ): QueryTxVotersRequest {
    return QueryTxVotersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryTxVotersRequest>, I>>(
    object: I
  ): QueryTxVotersRequest {
    const message = createBaseQueryTxVotersRequest();
    message.txId = object.txId ?? "";
    message.height = object.height ?? "";
    return message;
  },
};

function createBasePlannedOutTx(): PlannedOutTx {
  return { chain: "", toAddress: "", coin: undefined, refund: false };
}

export const PlannedOutTx = {
  encode(
    message: PlannedOutTx,
    writer: BinaryWriter = BinaryWriter.create()
  ): BinaryWriter {
    if (message.chain !== "") {
      writer.uint32(10).string(message.chain);
    }
    if (message.toAddress !== "") {
      writer.uint32(18).string(message.toAddress);
    }
    if (message.coin !== undefined) {
      Coin.encode(message.coin, writer.uint32(26).fork()).ldelim();
    }
    if (message.refund !== false) {
      writer.uint32(32).bool(message.refund);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlannedOutTx {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlannedOutTx();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.chain = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.toAddress = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.coin = Coin.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.refund = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlannedOutTx {
    return {
      chain: isSet(object.chain) ? globalThis.String(object.chain) : "",
      toAddress: isSet(object.toAddress)
        ? globalThis.String(object.toAddress)
        : "",
      coin: isSet(object.coin) ? Coin.fromJSON(object.coin) : undefined,
      refund: isSet(object.refund) ? globalThis.Boolean(object.refund) : false,
    };
  },

  toJSON(message: PlannedOutTx): unknown {
    const obj: any = {};
    if (message.chain !== "") {
      obj.chain = message.chain;
    }
    if (message.toAddress !== "") {
      obj.toAddress = message.toAddress;
    }
    if (message.coin !== undefined) {
      obj.coin = Coin.toJSON(message.coin);
    }
    if (message.refund !== false) {
      obj.refund = message.refund;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PlannedOutTx>, I>>(
    base?: I
  ): PlannedOutTx {
    return PlannedOutTx.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PlannedOutTx>, I>>(
    object: I
  ): PlannedOutTx {
    const message = createBasePlannedOutTx();
    message.chain = object.chain ?? "";
    message.toAddress = object.toAddress ?? "";
    message.coin =
      object.coin !== undefined && object.coin !== null
        ? Coin.fromPartial(object.coin)
        : undefined;
    message.refund = object.refund ?? false;
    return message;
  },
};

function createBaseInboundObservedStage(): InboundObservedStage {
  return {
    started: false,
    preConfirmationCount: 0,
    finalCount: 0,
    completed: false,
  };
}

export const InboundObservedStage = {
  encode(
    message: InboundObservedStage,
    writer: BinaryWriter = BinaryWriter.create()
  ): BinaryWriter {
    if (message.started !== false) {
      writer.uint32(8).bool(message.started);
    }
    if (message.preConfirmationCount !== 0) {
      writer.uint32(16).int64(message.preConfirmationCount);
    }
    if (message.finalCount !== 0) {
      writer.uint32(24).int64(message.finalCount);
    }
    if (message.completed !== false) {
      writer.uint32(32).bool(message.completed);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): InboundObservedStage {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInboundObservedStage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.started = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.preConfirmationCount = Number(reader.int64());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.finalCount = Number(reader.int64());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.completed = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InboundObservedStage {
    return {
      started: isSet(object.started)
        ? globalThis.Boolean(object.started)
        : false,
      preConfirmationCount: isSet(object.preConfirmationCount)
        ? globalThis.Number(object.preConfirmationCount)
        : 0,
      finalCount: isSet(object.finalCount)
        ? globalThis.Number(object.finalCount)
        : 0,
      completed: isSet(object.completed)
        ? globalThis.Boolean(object.completed)
        : false,
    };
  },

  toJSON(message: InboundObservedStage): unknown {
    const obj: any = {};
    if (message.started !== false) {
      obj.started = message.started;
    }
    if (message.preConfirmationCount !== 0) {
      obj.preConfirmationCount = Math.round(message.preConfirmationCount);
    }
    if (message.finalCount !== 0) {
      obj.finalCount = Math.round(message.finalCount);
    }
    if (message.completed !== false) {
      obj.completed = message.completed;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InboundObservedStage>, I>>(
    base?: I
  ): InboundObservedStage {
    return InboundObservedStage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InboundObservedStage>, I>>(
    object: I
  ): InboundObservedStage {
    const message = createBaseInboundObservedStage();
    message.started = object.started ?? false;
    message.preConfirmationCount = object.preConfirmationCount ?? 0;
    message.finalCount = object.finalCount ?? 0;
    message.completed = object.completed ?? false;
    return message;
  },
};

function createBaseInboundConfirmationCountedStage(): InboundConfirmationCountedStage {
  return {
    countingStartHeight: 0,
    chain: "",
    externalObservedHeight: 0,
    externalConfirmationDelayHeight: 0,
    remainingConfirmationSeconds: 0,
    completed: false,
  };
}

export const InboundConfirmationCountedStage = {
  encode(
    message: InboundConfirmationCountedStage,
    writer: BinaryWriter = BinaryWriter.create()
  ): BinaryWriter {
    if (message.countingStartHeight !== 0) {
      writer.uint32(8).int64(message.countingStartHeight);
    }
    if (message.chain !== "") {
      writer.uint32(18).string(message.chain);
    }
    if (message.externalObservedHeight !== 0) {
      writer.uint32(24).int64(message.externalObservedHeight);
    }
    if (message.externalConfirmationDelayHeight !== 0) {
      writer.uint32(32).int64(message.externalConfirmationDelayHeight);
    }
    if (message.remainingConfirmationSeconds !== 0) {
      writer.uint32(40).int64(message.remainingConfirmationSeconds);
    }
    if (message.completed !== false) {
      writer.uint32(48).bool(message.completed);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): InboundConfirmationCountedStage {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInboundConfirmationCountedStage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.countingStartHeight = Number(reader.int64());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.chain = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.externalObservedHeight = Number(reader.int64());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.externalConfirmationDelayHeight = Number(reader.int64());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.remainingConfirmationSeconds = Number(reader.int64());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.completed = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InboundConfirmationCountedStage {
    return {
      countingStartHeight: isSet(object.countingStartHeight)
        ? globalThis.Number(object.countingStartHeight)
        : 0,
      chain: isSet(object.chain) ? globalThis.String(object.chain) : "",
      externalObservedHeight: isSet(object.externalObservedHeight)
        ? globalThis.Number(object.externalObservedHeight)
        : 0,
      externalConfirmationDelayHeight: isSet(
        object.externalConfirmationDelayHeight
      )
        ? globalThis.Number(object.externalConfirmationDelayHeight)
        : 0,
      remainingConfirmationSeconds: isSet(object.remainingConfirmationSeconds)
        ? globalThis.Number(object.remainingConfirmationSeconds)
        : 0,
      completed: isSet(object.completed)
        ? globalThis.Boolean(object.completed)
        : false,
    };
  },

  toJSON(message: InboundConfirmationCountedStage): unknown {
    const obj: any = {};
    if (message.countingStartHeight !== 0) {
      obj.countingStartHeight = Math.round(message.countingStartHeight);
    }
    if (message.chain !== "") {
      obj.chain = message.chain;
    }
    if (message.externalObservedHeight !== 0) {
      obj.externalObservedHeight = Math.round(message.externalObservedHeight);
    }
    if (message.externalConfirmationDelayHeight !== 0) {
      obj.externalConfirmationDelayHeight = Math.round(
        message.externalConfirmationDelayHeight
      );
    }
    if (message.remainingConfirmationSeconds !== 0) {
      obj.remainingConfirmationSeconds = Math.round(
        message.remainingConfirmationSeconds
      );
    }
    if (message.completed !== false) {
      obj.completed = message.completed;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InboundConfirmationCountedStage>, I>>(
    base?: I
  ): InboundConfirmationCountedStage {
    return InboundConfirmationCountedStage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InboundConfirmationCountedStage>, I>>(
    object: I
  ): InboundConfirmationCountedStage {
    const message = createBaseInboundConfirmationCountedStage();
    message.countingStartHeight = object.countingStartHeight ?? 0;
    message.chain = object.chain ?? "";
    message.externalObservedHeight = object.externalObservedHeight ?? 0;
    message.externalConfirmationDelayHeight =
      object.externalConfirmationDelayHeight ?? 0;
    message.remainingConfirmationSeconds =
      object.remainingConfirmationSeconds ?? 0;
    message.completed = object.completed ?? false;
    return message;
  },
};

function createBaseInboundFinalisedStage(): InboundFinalisedStage {
  return { completed: false };
}

export const InboundFinalisedStage = {
  encode(
    message: InboundFinalisedStage,
    writer: BinaryWriter = BinaryWriter.create()
  ): BinaryWriter {
    if (message.completed !== false) {
      writer.uint32(8).bool(message.completed);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): InboundFinalisedStage {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInboundFinalisedStage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.completed = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InboundFinalisedStage {
    return {
      completed: isSet(object.completed)
        ? globalThis.Boolean(object.completed)
        : false,
    };
  },

  toJSON(message: InboundFinalisedStage): unknown {
    const obj: any = {};
    if (message.completed !== false) {
      obj.completed = message.completed;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InboundFinalisedStage>, I>>(
    base?: I
  ): InboundFinalisedStage {
    return InboundFinalisedStage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InboundFinalisedStage>, I>>(
    object: I
  ): InboundFinalisedStage {
    const message = createBaseInboundFinalisedStage();
    message.completed = object.completed ?? false;
    return message;
  },
};

function createBaseSwapStatus(): SwapStatus {
  return { pending: false, streaming: undefined };
}

export const SwapStatus = {
  encode(
    message: SwapStatus,
    writer: BinaryWriter = BinaryWriter.create()
  ): BinaryWriter {
    if (message.pending !== false) {
      writer.uint32(8).bool(message.pending);
    }
    if (message.streaming !== undefined) {
      StreamingStatus.encode(
        message.streaming,
        writer.uint32(18).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SwapStatus {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSwapStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.pending = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.streaming = StreamingStatus.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SwapStatus {
    return {
      pending: isSet(object.pending)
        ? globalThis.Boolean(object.pending)
        : false,
      streaming: isSet(object.streaming)
        ? StreamingStatus.fromJSON(object.streaming)
        : undefined,
    };
  },

  toJSON(message: SwapStatus): unknown {
    const obj: any = {};
    if (message.pending !== false) {
      obj.pending = message.pending;
    }
    if (message.streaming !== undefined) {
      obj.streaming = StreamingStatus.toJSON(message.streaming);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SwapStatus>, I>>(base?: I): SwapStatus {
    return SwapStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SwapStatus>, I>>(
    object: I
  ): SwapStatus {
    const message = createBaseSwapStatus();
    message.pending = object.pending ?? false;
    message.streaming =
      object.streaming !== undefined && object.streaming !== null
        ? StreamingStatus.fromPartial(object.streaming)
        : undefined;
    return message;
  },
};

function createBaseStreamingStatus(): StreamingStatus {
  return { interval: 0, quantity: 0, count: 0 };
}

export const StreamingStatus = {
  encode(
    message: StreamingStatus,
    writer: BinaryWriter = BinaryWriter.create()
  ): BinaryWriter {
    if (message.interval !== 0) {
      writer.uint32(8).int64(message.interval);
    }
    if (message.quantity !== 0) {
      writer.uint32(16).int64(message.quantity);
    }
    if (message.count !== 0) {
      writer.uint32(24).int64(message.count);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamingStatus {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamingStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.interval = Number(reader.int64());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.quantity = Number(reader.int64());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.count = Number(reader.int64());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamingStatus {
    return {
      interval: isSet(object.interval) ? globalThis.Number(object.interval) : 0,
      quantity: isSet(object.quantity) ? globalThis.Number(object.quantity) : 0,
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
    };
  },

  toJSON(message: StreamingStatus): unknown {
    const obj: any = {};
    if (message.interval !== 0) {
      obj.interval = Math.round(message.interval);
    }
    if (message.quantity !== 0) {
      obj.quantity = Math.round(message.quantity);
    }
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StreamingStatus>, I>>(
    base?: I
  ): StreamingStatus {
    return StreamingStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StreamingStatus>, I>>(
    object: I
  ): StreamingStatus {
    const message = createBaseStreamingStatus();
    message.interval = object.interval ?? 0;
    message.quantity = object.quantity ?? 0;
    message.count = object.count ?? 0;
    return message;
  },
};

function createBaseSwapFinalisedStage(): SwapFinalisedStage {
  return { completed: false };
}

export const SwapFinalisedStage = {
  encode(
    message: SwapFinalisedStage,
    writer: BinaryWriter = BinaryWriter.create()
  ): BinaryWriter {
    if (message.completed !== false) {
      writer.uint32(8).bool(message.completed);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): SwapFinalisedStage {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSwapFinalisedStage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.completed = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SwapFinalisedStage {
    return {
      completed: isSet(object.completed)
        ? globalThis.Boolean(object.completed)
        : false,
    };
  },

  toJSON(message: SwapFinalisedStage): unknown {
    const obj: any = {};
    if (message.completed !== false) {
      obj.completed = message.completed;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SwapFinalisedStage>, I>>(
    base?: I
  ): SwapFinalisedStage {
    return SwapFinalisedStage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SwapFinalisedStage>, I>>(
    object: I
  ): SwapFinalisedStage {
    const message = createBaseSwapFinalisedStage();
    message.completed = object.completed ?? false;
    return message;
  },
};

function createBaseOutboundDelayStage(): OutboundDelayStage {
  return {
    remainingDelayBlocks: 0,
    remainingDelaySeconds: 0,
    completed: false,
  };
}

export const OutboundDelayStage = {
  encode(
    message: OutboundDelayStage,
    writer: BinaryWriter = BinaryWriter.create()
  ): BinaryWriter {
    if (message.remainingDelayBlocks !== 0) {
      writer.uint32(8).int64(message.remainingDelayBlocks);
    }
    if (message.remainingDelaySeconds !== 0) {
      writer.uint32(16).int64(message.remainingDelaySeconds);
    }
    if (message.completed !== false) {
      writer.uint32(24).bool(message.completed);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): OutboundDelayStage {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOutboundDelayStage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.remainingDelayBlocks = Number(reader.int64());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.remainingDelaySeconds = Number(reader.int64());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.completed = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OutboundDelayStage {
    return {
      remainingDelayBlocks: isSet(object.remainingDelayBlocks)
        ? globalThis.Number(object.remainingDelayBlocks)
        : 0,
      remainingDelaySeconds: isSet(object.remainingDelaySeconds)
        ? globalThis.Number(object.remainingDelaySeconds)
        : 0,
      completed: isSet(object.completed)
        ? globalThis.Boolean(object.completed)
        : false,
    };
  },

  toJSON(message: OutboundDelayStage): unknown {
    const obj: any = {};
    if (message.remainingDelayBlocks !== 0) {
      obj.remainingDelayBlocks = Math.round(message.remainingDelayBlocks);
    }
    if (message.remainingDelaySeconds !== 0) {
      obj.remainingDelaySeconds = Math.round(message.remainingDelaySeconds);
    }
    if (message.completed !== false) {
      obj.completed = message.completed;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OutboundDelayStage>, I>>(
    base?: I
  ): OutboundDelayStage {
    return OutboundDelayStage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OutboundDelayStage>, I>>(
    object: I
  ): OutboundDelayStage {
    const message = createBaseOutboundDelayStage();
    message.remainingDelayBlocks = object.remainingDelayBlocks ?? 0;
    message.remainingDelaySeconds = object.remainingDelaySeconds ?? 0;
    message.completed = object.completed ?? false;
    return message;
  },
};

function createBaseOutboundSignedStage(): OutboundSignedStage {
  return {
    scheduledOutboundHeight: 0,
    blocksSinceScheduled: undefined,
    completed: false,
  };
}

export const OutboundSignedStage = {
  encode(
    message: OutboundSignedStage,
    writer: BinaryWriter = BinaryWriter.create()
  ): BinaryWriter {
    if (message.scheduledOutboundHeight !== 0) {
      writer.uint32(8).int64(message.scheduledOutboundHeight);
    }
    if (message.blocksSinceScheduled !== undefined) {
      ProtoInt64.encode(
        message.blocksSinceScheduled,
        writer.uint32(18).fork()
      ).ldelim();
    }
    if (message.completed !== false) {
      writer.uint32(24).bool(message.completed);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): OutboundSignedStage {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOutboundSignedStage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.scheduledOutboundHeight = Number(reader.int64());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.blocksSinceScheduled = ProtoInt64.decode(
            reader,
            reader.uint32()
          );
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.completed = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OutboundSignedStage {
    return {
      scheduledOutboundHeight: isSet(object.scheduledOutboundHeight)
        ? globalThis.Number(object.scheduledOutboundHeight)
        : 0,
      blocksSinceScheduled: isSet(object.blocksSinceScheduled)
        ? ProtoInt64.fromJSON(object.blocksSinceScheduled)
        : undefined,
      completed: isSet(object.completed)
        ? globalThis.Boolean(object.completed)
        : false,
    };
  },

  toJSON(message: OutboundSignedStage): unknown {
    const obj: any = {};
    if (message.scheduledOutboundHeight !== 0) {
      obj.scheduledOutboundHeight = Math.round(message.scheduledOutboundHeight);
    }
    if (message.blocksSinceScheduled !== undefined) {
      obj.blocksSinceScheduled = ProtoInt64.toJSON(
        message.blocksSinceScheduled
      );
    }
    if (message.completed !== false) {
      obj.completed = message.completed;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OutboundSignedStage>, I>>(
    base?: I
  ): OutboundSignedStage {
    return OutboundSignedStage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OutboundSignedStage>, I>>(
    object: I
  ): OutboundSignedStage {
    const message = createBaseOutboundSignedStage();
    message.scheduledOutboundHeight = object.scheduledOutboundHeight ?? 0;
    message.blocksSinceScheduled =
      object.blocksSinceScheduled !== undefined &&
      object.blocksSinceScheduled !== null
        ? ProtoInt64.fromPartial(object.blocksSinceScheduled)
        : undefined;
    message.completed = object.completed ?? false;
    return message;
  },
};
