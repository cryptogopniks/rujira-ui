// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               unknown
// source: types/tx.proto

/* eslint-disable */

import { BinaryReader, BinaryWriter } from "../../binary";
import {
  MsgExecuteContract,
  MsgExecuteContractResponse,
  MsgInstantiateContract,
  MsgInstantiateContract2,
  MsgInstantiateContract2Response,
  MsgInstantiateContractResponse,
  MsgMigrateContract,
  MsgMigrateContractResponse,
  MsgStoreCode,
  MsgStoreCodeResponse,
} from "../../cosmwasm/wasm/v1/tx";
import { DeepPartial, Exact } from "../../helpers";
import { MsgBan } from "./msg_ban";
import { MsgDeposit } from "./msg_deposit";
import { MsgErrataTx } from "./msg_errata";
import { MsgMimir } from "./msg_mimir";
import { MsgNetworkFee } from "./msg_network_fee";
import { MsgNodePauseChain } from "./msg_node_pause_chain";
import { MsgObservedTxIn } from "./msg_observed_txin";
import { MsgObservedTxOut } from "./msg_observed_txout";
import { MsgSend } from "./msg_send";
import { MsgSetIPAddress } from "./msg_set_ip_address";
import { MsgSetNodeKeys } from "./msg_set_node_keys";
import { MsgSolvency } from "./msg_solvency";
import { MsgTssKeysignFail } from "./msg_tss_keysign_fail";
import { MsgTssPool } from "./msg_tss_pool";
import {
  MsgApproveUpgrade,
  MsgProposeUpgrade,
  MsgRejectUpgrade,
} from "./msg_upgrade";
import { MsgSetVersion } from "./msg_version";

export const protobufPackage = "types";

/** MsgEmpty is the return type for all current Msg Server messages */
export interface MsgEmpty {}

function createBaseMsgEmpty(): MsgEmpty {
  return {};
}

export const MsgEmpty = {
  encode(
    _: MsgEmpty,
    writer: BinaryWriter = BinaryWriter.create()
  ): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgEmpty {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgEmpty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgEmpty {
    return {};
  },

  toJSON(_: MsgEmpty): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgEmpty>, I>>(base?: I): MsgEmpty {
    return MsgEmpty.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgEmpty>, I>>(_: I): MsgEmpty {
    const message = createBaseMsgEmpty();
    return message;
  },
};

/** Msg defines the bank Msg service. */
export interface Msg {
  Ban(request: MsgBan): Promise<MsgEmpty>;
  Deposit(request: MsgDeposit): Promise<MsgEmpty>;
  ErrataTx(request: MsgErrataTx): Promise<MsgEmpty>;
  Mimir(request: MsgMimir): Promise<MsgEmpty>;
  NetworkFee(request: MsgNetworkFee): Promise<MsgEmpty>;
  NodePauseChain(request: MsgNodePauseChain): Promise<MsgEmpty>;
  ObservedTxIn(request: MsgObservedTxIn): Promise<MsgEmpty>;
  ObservedTxOut(request: MsgObservedTxOut): Promise<MsgEmpty>;
  ThorSend(request: MsgSend): Promise<MsgEmpty>;
  SetIPAddress(request: MsgSetIPAddress): Promise<MsgEmpty>;
  SetNodeKeys(request: MsgSetNodeKeys): Promise<MsgEmpty>;
  Solvency(request: MsgSolvency): Promise<MsgEmpty>;
  TssKeysignFail(request: MsgTssKeysignFail): Promise<MsgEmpty>;
  TssPool(request: MsgTssPool): Promise<MsgEmpty>;
  SetVersion(request: MsgSetVersion): Promise<MsgEmpty>;
  ProposeUpgrade(request: MsgProposeUpgrade): Promise<MsgEmpty>;
  ApproveUpgrade(request: MsgApproveUpgrade): Promise<MsgEmpty>;
  RejectUpgrade(request: MsgRejectUpgrade): Promise<MsgEmpty>;
  /** CosmWasm interface cloned in order so that we can register the x/thorchain message server as the server for x/wasm messages, and route through version control */
  StoreCode(request: MsgStoreCode): Promise<MsgStoreCodeResponse>;
  InstantiateContract(
    request: MsgInstantiateContract
  ): Promise<MsgInstantiateContractResponse>;
  InstantiateContract2(
    request: MsgInstantiateContract2
  ): Promise<MsgInstantiateContract2Response>;
  ExecuteContract(
    request: MsgExecuteContract
  ): Promise<MsgExecuteContractResponse>;
  MigrateContract(
    request: MsgMigrateContract
  ): Promise<MsgMigrateContractResponse>;
  // SudoContract(request: MsgSudoContract): Promise<MsgSudoContractResponse>;
}

export const MsgServiceName = "types.Msg";
export class MsgClientImpl implements Msg {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || MsgServiceName;
    this.rpc = rpc;
    this.Ban = this.Ban.bind(this);
    this.Deposit = this.Deposit.bind(this);
    this.ErrataTx = this.ErrataTx.bind(this);
    this.Mimir = this.Mimir.bind(this);
    this.NetworkFee = this.NetworkFee.bind(this);
    this.NodePauseChain = this.NodePauseChain.bind(this);
    this.ObservedTxIn = this.ObservedTxIn.bind(this);
    this.ObservedTxOut = this.ObservedTxOut.bind(this);
    this.ThorSend = this.ThorSend.bind(this);
    this.SetIPAddress = this.SetIPAddress.bind(this);
    this.SetNodeKeys = this.SetNodeKeys.bind(this);
    this.Solvency = this.Solvency.bind(this);
    this.TssKeysignFail = this.TssKeysignFail.bind(this);
    this.TssPool = this.TssPool.bind(this);
    this.SetVersion = this.SetVersion.bind(this);
    this.ProposeUpgrade = this.ProposeUpgrade.bind(this);
    this.ApproveUpgrade = this.ApproveUpgrade.bind(this);
    this.RejectUpgrade = this.RejectUpgrade.bind(this);
    this.StoreCode = this.StoreCode.bind(this);
    this.InstantiateContract = this.InstantiateContract.bind(this);
    this.InstantiateContract2 = this.InstantiateContract2.bind(this);
    this.ExecuteContract = this.ExecuteContract.bind(this);
    this.MigrateContract = this.MigrateContract.bind(this);
    // this.SudoContract = this.SudoContract.bind(this);
  }
  Ban(request: MsgBan): Promise<MsgEmpty> {
    const data = MsgBan.encode(request).finish();
    const promise = this.rpc.request(this.service, "Ban", data);
    return promise.then((data) => MsgEmpty.decode(new BinaryReader(data)));
  }

  Deposit(request: MsgDeposit): Promise<MsgEmpty> {
    const data = MsgDeposit.encode(request).finish();
    const promise = this.rpc.request(this.service, "Deposit", data);
    return promise.then((data) => MsgEmpty.decode(new BinaryReader(data)));
  }

  ErrataTx(request: MsgErrataTx): Promise<MsgEmpty> {
    const data = MsgErrataTx.encode(request).finish();
    const promise = this.rpc.request(this.service, "ErrataTx", data);
    return promise.then((data) => MsgEmpty.decode(new BinaryReader(data)));
  }

  Mimir(request: MsgMimir): Promise<MsgEmpty> {
    const data = MsgMimir.encode(request).finish();
    const promise = this.rpc.request(this.service, "Mimir", data);
    return promise.then((data) => MsgEmpty.decode(new BinaryReader(data)));
  }

  NetworkFee(request: MsgNetworkFee): Promise<MsgEmpty> {
    const data = MsgNetworkFee.encode(request).finish();
    const promise = this.rpc.request(this.service, "NetworkFee", data);
    return promise.then((data) => MsgEmpty.decode(new BinaryReader(data)));
  }

  NodePauseChain(request: MsgNodePauseChain): Promise<MsgEmpty> {
    const data = MsgNodePauseChain.encode(request).finish();
    const promise = this.rpc.request(this.service, "NodePauseChain", data);
    return promise.then((data) => MsgEmpty.decode(new BinaryReader(data)));
  }

  ObservedTxIn(request: MsgObservedTxIn): Promise<MsgEmpty> {
    const data = MsgObservedTxIn.encode(request).finish();
    const promise = this.rpc.request(this.service, "ObservedTxIn", data);
    return promise.then((data) => MsgEmpty.decode(new BinaryReader(data)));
  }

  ObservedTxOut(request: MsgObservedTxOut): Promise<MsgEmpty> {
    const data = MsgObservedTxOut.encode(request).finish();
    const promise = this.rpc.request(this.service, "ObservedTxOut", data);
    return promise.then((data) => MsgEmpty.decode(new BinaryReader(data)));
  }

  ThorSend(request: MsgSend): Promise<MsgEmpty> {
    const data = MsgSend.encode(request).finish();
    const promise = this.rpc.request(this.service, "ThorSend", data);
    return promise.then((data) => MsgEmpty.decode(new BinaryReader(data)));
  }

  SetIPAddress(request: MsgSetIPAddress): Promise<MsgEmpty> {
    const data = MsgSetIPAddress.encode(request).finish();
    const promise = this.rpc.request(this.service, "SetIPAddress", data);
    return promise.then((data) => MsgEmpty.decode(new BinaryReader(data)));
  }

  SetNodeKeys(request: MsgSetNodeKeys): Promise<MsgEmpty> {
    const data = MsgSetNodeKeys.encode(request).finish();
    const promise = this.rpc.request(this.service, "SetNodeKeys", data);
    return promise.then((data) => MsgEmpty.decode(new BinaryReader(data)));
  }

  Solvency(request: MsgSolvency): Promise<MsgEmpty> {
    const data = MsgSolvency.encode(request).finish();
    const promise = this.rpc.request(this.service, "Solvency", data);
    return promise.then((data) => MsgEmpty.decode(new BinaryReader(data)));
  }

  TssKeysignFail(request: MsgTssKeysignFail): Promise<MsgEmpty> {
    const data = MsgTssKeysignFail.encode(request).finish();
    const promise = this.rpc.request(this.service, "TssKeysignFail", data);
    return promise.then((data) => MsgEmpty.decode(new BinaryReader(data)));
  }

  TssPool(request: MsgTssPool): Promise<MsgEmpty> {
    const data = MsgTssPool.encode(request).finish();
    const promise = this.rpc.request(this.service, "TssPool", data);
    return promise.then((data) => MsgEmpty.decode(new BinaryReader(data)));
  }

  SetVersion(request: MsgSetVersion): Promise<MsgEmpty> {
    const data = MsgSetVersion.encode(request).finish();
    const promise = this.rpc.request(this.service, "SetVersion", data);
    return promise.then((data) => MsgEmpty.decode(new BinaryReader(data)));
  }

  ProposeUpgrade(request: MsgProposeUpgrade): Promise<MsgEmpty> {
    const data = MsgProposeUpgrade.encode(request).finish();
    const promise = this.rpc.request(this.service, "ProposeUpgrade", data);
    return promise.then((data) => MsgEmpty.decode(new BinaryReader(data)));
  }

  ApproveUpgrade(request: MsgApproveUpgrade): Promise<MsgEmpty> {
    const data = MsgApproveUpgrade.encode(request).finish();
    const promise = this.rpc.request(this.service, "ApproveUpgrade", data);
    return promise.then((data) => MsgEmpty.decode(new BinaryReader(data)));
  }

  RejectUpgrade(request: MsgRejectUpgrade): Promise<MsgEmpty> {
    const data = MsgRejectUpgrade.encode(request).finish();
    const promise = this.rpc.request(this.service, "RejectUpgrade", data);
    return promise.then((data) => MsgEmpty.decode(new BinaryReader(data)));
  }

  StoreCode(request: MsgStoreCode): Promise<MsgStoreCodeResponse> {
    const data = MsgStoreCode.encode(request).finish();
    const promise = this.rpc.request(this.service, "StoreCode", data);
    return promise.then((data) =>
      MsgStoreCodeResponse.decode(new BinaryReader(data))
    );
  }

  InstantiateContract(
    request: MsgInstantiateContract
  ): Promise<MsgInstantiateContractResponse> {
    const data = MsgInstantiateContract.encode(request).finish();
    const promise = this.rpc.request(this.service, "InstantiateContract", data);
    return promise.then((data) =>
      MsgInstantiateContractResponse.decode(new BinaryReader(data))
    );
  }

  InstantiateContract2(
    request: MsgInstantiateContract2
  ): Promise<MsgInstantiateContract2Response> {
    const data = MsgInstantiateContract2.encode(request).finish();
    const promise = this.rpc.request(
      this.service,
      "InstantiateContract2",
      data
    );
    return promise.then((data) =>
      MsgInstantiateContract2Response.decode(new BinaryReader(data))
    );
  }

  ExecuteContract(
    request: MsgExecuteContract
  ): Promise<MsgExecuteContractResponse> {
    const data = MsgExecuteContract.encode(request).finish();
    const promise = this.rpc.request(this.service, "ExecuteContract", data);
    return promise.then((data) =>
      MsgExecuteContractResponse.decode(new BinaryReader(data))
    );
  }

  MigrateContract(
    request: MsgMigrateContract
  ): Promise<MsgMigrateContractResponse> {
    const data = MsgMigrateContract.encode(request).finish();
    const promise = this.rpc.request(this.service, "MigrateContract", data);
    return promise.then((data) =>
      MsgMigrateContractResponse.decode(new BinaryReader(data))
    );
  }

  // SudoContract(request: MsgSudoContract): Promise<MsgSudoContractResponse> {
  //   const data = MsgSudoContract.encode(request).finish();
  //   const promise = this.rpc.request(this.service, "SudoContract", data);
  //   return promise.then((data) =>
  //     MsgSudoContractResponse.decode(new BinaryReader(data))
  //   );
  // }
}

interface Rpc {
  request(
    service: string,
    method: string,
    data: Uint8Array
  ): Promise<Uint8Array>;
}
