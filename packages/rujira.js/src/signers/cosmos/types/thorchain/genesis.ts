// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               unknown
// source: thorchain/genesis.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "../../binary";
import { Coin } from "../common/common";
import { MsgSwap } from "../types/msg_swap";
import { AffiliateFeeCollector } from "../types/type_affiliate_fee_collector";
import { ChainContract } from "../types/type_chain_contract";
import { SwapperClout } from "../types/type_clout";
import { LiquidityProvider } from "../types/type_liquidity_provider";
import { Loan } from "../types/type_loan";
import { NodeMimir } from "../types/type_mimir";
import { Network } from "../types/type_network";
import { NetworkFee } from "../types/type_network_fee";
import { BondProviders, NodeAccount } from "../types/type_node_account";
import { ObservedTxVoter } from "../types/type_observed_tx";
import { ProtocolOwnedLiquidity } from "../types/type_pol";
import { Pool } from "../types/type_pool";
import { ReserveContributor } from "../types/type_reserve_contributor";
import { RUNEPool } from "../types/type_rune_pool";
import { RUNEProvider } from "../types/type_rune_provider";
import { SecuredAsset } from "../types/type_secured_asset";
import { StreamingSwap } from "../types/type_streaming_swap";
import { THORName } from "../types/type_thorname";
import { TradeAccount, TradeUnit } from "../types/type_trade_account";
import { TxOut } from "../types/type_tx_out";
import { Vault } from "../types/type_vault";

export const protobufPackage = "thorchain";

export interface lastChainHeight {
  chain: string;
  height: number;
}

export interface mimir {
  key: string;
  value: number;
}

export interface GenesisState {
  pools: Pool[];
  liquidityProviders: LiquidityProvider[];
  observedTxInVoters: ObservedTxVoter[];
  observedTxOutVoters: ObservedTxVoter[];
  txOuts: TxOut[];
  nodeAccounts: NodeAccount[];
  vaults: Vault[];
  reserve: number;
  lastSignedHeight: number;
  lastChainHeights: lastChainHeight[];
  reserveContributors: ReserveContributor[];
  network: Network | undefined;
  orderbookItems: MsgSwap[];
  networkFees: NetworkFee[];
  chainContracts: ChainContract[];
  THORNames: THORName[];
  mimirs: mimir[];
  /**
   * store_version is deprecated in v3.0.0
   *
   * @deprecated
   */
  storeVersion: number;
  bondProviders: BondProviders[];
  POL: ProtocolOwnedLiquidity | undefined;
  loans: Loan[];
  streamingSwaps: StreamingSwap[];
  swapQueueItems: MsgSwap[];
  swapperClout: SwapperClout[];
  tradeAccounts: TradeAccount[];
  tradeUnits: TradeUnit[];
  outboundFeeWithheldRune: Coin[];
  outboundFeeSpentRune: Coin[];
  runeProviders: RUNEProvider[];
  runePool: RUNEPool | undefined;
  nodeMimirs: NodeMimir[];
  affiliateCollectors: AffiliateFeeCollector[];
  loanTotalCollateral: Coin[];
  securedAssets: SecuredAsset[];
}

function createBaselastChainHeight(): lastChainHeight {
  return { chain: "", height: 0 };
}

export const lastChainHeight = {
  encode(
    message: lastChainHeight,
    writer: BinaryWriter = BinaryWriter.create()
  ): BinaryWriter {
    if (message.chain !== "") {
      writer.uint32(10).string(message.chain);
    }
    if (message.height !== 0) {
      writer.uint32(16).int64(message.height);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): lastChainHeight {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaselastChainHeight();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.chain = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.height = Number(reader.int64());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): lastChainHeight {
    return {
      chain: isSet(object.chain) ? globalThis.String(object.chain) : "",
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
    };
  },

  toJSON(message: lastChainHeight): unknown {
    const obj: any = {};
    if (message.chain !== "") {
      obj.chain = message.chain;
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<lastChainHeight>, I>>(
    base?: I
  ): lastChainHeight {
    return lastChainHeight.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<lastChainHeight>, I>>(
    object: I
  ): lastChainHeight {
    const message = createBaselastChainHeight();
    message.chain = object.chain ?? "";
    message.height = object.height ?? 0;
    return message;
  },
};

function createBasemimir(): mimir {
  return { key: "", value: 0 };
}

export const mimir = {
  encode(
    message: mimir,
    writer: BinaryWriter = BinaryWriter.create()
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(16).int64(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): mimir {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasemimir();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.value = Number(reader.int64());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): mimir {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: mimir): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<mimir>, I>>(base?: I): mimir {
    return mimir.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<mimir>, I>>(object: I): mimir {
    const message = createBasemimir();
    message.key = object.key ?? "";
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseGenesisState(): GenesisState {
  return {
    pools: [],
    liquidityProviders: [],
    observedTxInVoters: [],
    observedTxOutVoters: [],
    txOuts: [],
    nodeAccounts: [],
    vaults: [],
    reserve: 0,
    lastSignedHeight: 0,
    lastChainHeights: [],
    reserveContributors: [],
    network: undefined,
    orderbookItems: [],
    networkFees: [],
    chainContracts: [],
    THORNames: [],
    mimirs: [],
    storeVersion: 0,
    bondProviders: [],
    POL: undefined,
    loans: [],
    streamingSwaps: [],
    swapQueueItems: [],
    swapperClout: [],
    tradeAccounts: [],
    tradeUnits: [],
    outboundFeeWithheldRune: [],
    outboundFeeSpentRune: [],
    runeProviders: [],
    runePool: undefined,
    nodeMimirs: [],
    affiliateCollectors: [],
    loanTotalCollateral: [],
    securedAssets: [],
  };
}

export const GenesisState = {
  encode(
    message: GenesisState,
    writer: BinaryWriter = BinaryWriter.create()
  ): BinaryWriter {
    for (const v of message.pools) {
      Pool.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.liquidityProviders) {
      LiquidityProvider.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.observedTxInVoters) {
      ObservedTxVoter.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.observedTxOutVoters) {
      ObservedTxVoter.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.txOuts) {
      TxOut.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    for (const v of message.nodeAccounts) {
      NodeAccount.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    for (const v of message.vaults) {
      Vault.encode(v!, writer.uint32(58).fork()).ldelim();
    }
    if (message.reserve !== 0) {
      writer.uint32(64).uint64(message.reserve);
    }
    if (message.lastSignedHeight !== 0) {
      writer.uint32(80).int64(message.lastSignedHeight);
    }
    for (const v of message.lastChainHeights) {
      lastChainHeight.encode(v!, writer.uint32(90).fork()).ldelim();
    }
    for (const v of message.reserveContributors) {
      ReserveContributor.encode(v!, writer.uint32(98).fork()).ldelim();
    }
    if (message.network !== undefined) {
      Network.encode(message.network, writer.uint32(106).fork()).ldelim();
    }
    for (const v of message.orderbookItems) {
      MsgSwap.encode(v!, writer.uint32(154).fork()).ldelim();
    }
    for (const v of message.networkFees) {
      NetworkFee.encode(v!, writer.uint32(162).fork()).ldelim();
    }
    for (const v of message.chainContracts) {
      ChainContract.encode(v!, writer.uint32(178).fork()).ldelim();
    }
    for (const v of message.THORNames) {
      THORName.encode(v!, writer.uint32(186).fork()).ldelim();
    }
    for (const v of message.mimirs) {
      mimir.encode(v!, writer.uint32(194).fork()).ldelim();
    }
    if (message.storeVersion !== 0) {
      writer.uint32(200).int64(message.storeVersion);
    }
    for (const v of message.bondProviders) {
      BondProviders.encode(v!, writer.uint32(210).fork()).ldelim();
    }
    if (message.POL !== undefined) {
      ProtocolOwnedLiquidity.encode(
        message.POL,
        writer.uint32(218).fork()
      ).ldelim();
    }
    for (const v of message.loans) {
      Loan.encode(v!, writer.uint32(226).fork()).ldelim();
    }
    for (const v of message.streamingSwaps) {
      StreamingSwap.encode(v!, writer.uint32(234).fork()).ldelim();
    }
    for (const v of message.swapQueueItems) {
      MsgSwap.encode(v!, writer.uint32(242).fork()).ldelim();
    }
    for (const v of message.swapperClout) {
      SwapperClout.encode(v!, writer.uint32(250).fork()).ldelim();
    }
    for (const v of message.tradeAccounts) {
      TradeAccount.encode(v!, writer.uint32(258).fork()).ldelim();
    }
    for (const v of message.tradeUnits) {
      TradeUnit.encode(v!, writer.uint32(266).fork()).ldelim();
    }
    for (const v of message.outboundFeeWithheldRune) {
      Coin.encode(v!, writer.uint32(274).fork()).ldelim();
    }
    for (const v of message.outboundFeeSpentRune) {
      Coin.encode(v!, writer.uint32(282).fork()).ldelim();
    }
    for (const v of message.runeProviders) {
      RUNEProvider.encode(v!, writer.uint32(290).fork()).ldelim();
    }
    if (message.runePool !== undefined) {
      RUNEPool.encode(message.runePool, writer.uint32(298).fork()).ldelim();
    }
    for (const v of message.nodeMimirs) {
      NodeMimir.encode(v!, writer.uint32(306).fork()).ldelim();
    }
    for (const v of message.affiliateCollectors) {
      AffiliateFeeCollector.encode(v!, writer.uint32(314).fork()).ldelim();
    }
    for (const v of message.loanTotalCollateral) {
      Coin.encode(v!, writer.uint32(322).fork()).ldelim();
    }
    for (const v of message.securedAssets) {
      SecuredAsset.encode(v!, writer.uint32(330).fork()).ldelim();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenesisState {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenesisState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pools.push(Pool.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.liquidityProviders.push(
            LiquidityProvider.decode(reader, reader.uint32())
          );
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.observedTxInVoters.push(
            ObservedTxVoter.decode(reader, reader.uint32())
          );
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.observedTxOutVoters.push(
            ObservedTxVoter.decode(reader, reader.uint32())
          );
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.txOuts.push(TxOut.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.nodeAccounts.push(
            NodeAccount.decode(reader, reader.uint32())
          );
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.vaults.push(Vault.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.reserve = longToNumber(reader.uint64() as Long);
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.lastSignedHeight = Number(reader.int64());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.lastChainHeights.push(
            lastChainHeight.decode(reader, reader.uint32())
          );
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.reserveContributors.push(
            ReserveContributor.decode(reader, reader.uint32())
          );
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.network = Network.decode(reader, reader.uint32());
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.orderbookItems.push(MsgSwap.decode(reader, reader.uint32()));
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.networkFees.push(NetworkFee.decode(reader, reader.uint32()));
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.chainContracts.push(
            ChainContract.decode(reader, reader.uint32())
          );
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.THORNames.push(THORName.decode(reader, reader.uint32()));
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }

          message.mimirs.push(mimir.decode(reader, reader.uint32()));
          continue;
        case 25:
          if (tag !== 200) {
            break;
          }

          message.storeVersion = Number(reader.int64());
          continue;
        case 26:
          if (tag !== 210) {
            break;
          }

          message.bondProviders.push(
            BondProviders.decode(reader, reader.uint32())
          );
          continue;
        case 27:
          if (tag !== 218) {
            break;
          }

          message.POL = ProtocolOwnedLiquidity.decode(reader, reader.uint32());
          continue;
        case 28:
          if (tag !== 226) {
            break;
          }

          message.loans.push(Loan.decode(reader, reader.uint32()));
          continue;
        case 29:
          if (tag !== 234) {
            break;
          }

          message.streamingSwaps.push(
            StreamingSwap.decode(reader, reader.uint32())
          );
          continue;
        case 30:
          if (tag !== 242) {
            break;
          }

          message.swapQueueItems.push(MsgSwap.decode(reader, reader.uint32()));
          continue;
        case 31:
          if (tag !== 250) {
            break;
          }

          message.swapperClout.push(
            SwapperClout.decode(reader, reader.uint32())
          );
          continue;
        case 32:
          if (tag !== 258) {
            break;
          }

          message.tradeAccounts.push(
            TradeAccount.decode(reader, reader.uint32())
          );
          continue;
        case 33:
          if (tag !== 266) {
            break;
          }

          message.tradeUnits.push(TradeUnit.decode(reader, reader.uint32()));
          continue;
        case 34:
          if (tag !== 274) {
            break;
          }

          message.outboundFeeWithheldRune.push(
            Coin.decode(reader, reader.uint32())
          );
          continue;
        case 35:
          if (tag !== 282) {
            break;
          }

          message.outboundFeeSpentRune.push(
            Coin.decode(reader, reader.uint32())
          );
          continue;
        case 36:
          if (tag !== 290) {
            break;
          }

          message.runeProviders.push(
            RUNEProvider.decode(reader, reader.uint32())
          );
          continue;
        case 37:
          if (tag !== 298) {
            break;
          }

          message.runePool = RUNEPool.decode(reader, reader.uint32());
          continue;
        case 38:
          if (tag !== 306) {
            break;
          }

          message.nodeMimirs.push(NodeMimir.decode(reader, reader.uint32()));
          continue;
        case 39:
          if (tag !== 314) {
            break;
          }

          message.affiliateCollectors.push(
            AffiliateFeeCollector.decode(reader, reader.uint32())
          );
          continue;
        case 40:
          if (tag !== 322) {
            break;
          }

          message.loanTotalCollateral.push(
            Coin.decode(reader, reader.uint32())
          );
          continue;
        case 41:
          if (tag !== 330) {
            break;
          }

          message.securedAssets.push(
            SecuredAsset.decode(reader, reader.uint32())
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenesisState {
    return {
      pools: globalThis.Array.isArray(object?.pools)
        ? object.pools.map((e: any) => Pool.fromJSON(e))
        : [],
      liquidityProviders: globalThis.Array.isArray(object?.liquidityProviders)
        ? object.liquidityProviders.map((e: any) =>
            LiquidityProvider.fromJSON(e)
          )
        : [],
      observedTxInVoters: globalThis.Array.isArray(object?.observedTxInVoters)
        ? object.observedTxInVoters.map((e: any) => ObservedTxVoter.fromJSON(e))
        : [],
      observedTxOutVoters: globalThis.Array.isArray(object?.observedTxOutVoters)
        ? object.observedTxOutVoters.map((e: any) =>
            ObservedTxVoter.fromJSON(e)
          )
        : [],
      txOuts: globalThis.Array.isArray(object?.txOuts)
        ? object.txOuts.map((e: any) => TxOut.fromJSON(e))
        : [],
      nodeAccounts: globalThis.Array.isArray(object?.nodeAccounts)
        ? object.nodeAccounts.map((e: any) => NodeAccount.fromJSON(e))
        : [],
      vaults: globalThis.Array.isArray(object?.vaults)
        ? object.vaults.map((e: any) => Vault.fromJSON(e))
        : [],
      reserve: isSet(object.reserve) ? globalThis.Number(object.reserve) : 0,
      lastSignedHeight: isSet(object.lastSignedHeight)
        ? globalThis.Number(object.lastSignedHeight)
        : 0,
      lastChainHeights: globalThis.Array.isArray(object?.lastChainHeights)
        ? object.lastChainHeights.map((e: any) => lastChainHeight.fromJSON(e))
        : [],
      reserveContributors: globalThis.Array.isArray(object?.reserveContributors)
        ? object.reserveContributors.map((e: any) =>
            ReserveContributor.fromJSON(e)
          )
        : [],
      network: isSet(object.network)
        ? Network.fromJSON(object.network)
        : undefined,
      orderbookItems: globalThis.Array.isArray(object?.orderbookItems)
        ? object.orderbookItems.map((e: any) => MsgSwap.fromJSON(e))
        : [],
      networkFees: globalThis.Array.isArray(object?.networkFees)
        ? object.networkFees.map((e: any) => NetworkFee.fromJSON(e))
        : [],
      chainContracts: globalThis.Array.isArray(object?.chainContracts)
        ? object.chainContracts.map((e: any) => ChainContract.fromJSON(e))
        : [],
      THORNames: globalThis.Array.isArray(object?.THORNames)
        ? object.THORNames.map((e: any) => THORName.fromJSON(e))
        : [],
      mimirs: globalThis.Array.isArray(object?.mimirs)
        ? object.mimirs.map((e: any) => mimir.fromJSON(e))
        : [],
      storeVersion: isSet(object.storeVersion)
        ? globalThis.Number(object.storeVersion)
        : 0,
      bondProviders: globalThis.Array.isArray(object?.bondProviders)
        ? object.bondProviders.map((e: any) => BondProviders.fromJSON(e))
        : [],
      POL: isSet(object.POL)
        ? ProtocolOwnedLiquidity.fromJSON(object.POL)
        : undefined,
      loans: globalThis.Array.isArray(object?.loans)
        ? object.loans.map((e: any) => Loan.fromJSON(e))
        : [],
      streamingSwaps: globalThis.Array.isArray(object?.streamingSwaps)
        ? object.streamingSwaps.map((e: any) => StreamingSwap.fromJSON(e))
        : [],
      swapQueueItems: globalThis.Array.isArray(object?.swapQueueItems)
        ? object.swapQueueItems.map((e: any) => MsgSwap.fromJSON(e))
        : [],
      swapperClout: globalThis.Array.isArray(object?.swapperClout)
        ? object.swapperClout.map((e: any) => SwapperClout.fromJSON(e))
        : [],
      tradeAccounts: globalThis.Array.isArray(object?.tradeAccounts)
        ? object.tradeAccounts.map((e: any) => TradeAccount.fromJSON(e))
        : [],
      tradeUnits: globalThis.Array.isArray(object?.tradeUnits)
        ? object.tradeUnits.map((e: any) => TradeUnit.fromJSON(e))
        : [],
      outboundFeeWithheldRune: globalThis.Array.isArray(
        object?.outboundFeeWithheldRune
      )
        ? object.outboundFeeWithheldRune.map((e: any) => Coin.fromJSON(e))
        : [],
      outboundFeeSpentRune: globalThis.Array.isArray(
        object?.outboundFeeSpentRune
      )
        ? object.outboundFeeSpentRune.map((e: any) => Coin.fromJSON(e))
        : [],
      runeProviders: globalThis.Array.isArray(object?.runeProviders)
        ? object.runeProviders.map((e: any) => RUNEProvider.fromJSON(e))
        : [],
      runePool: isSet(object.runePool)
        ? RUNEPool.fromJSON(object.runePool)
        : undefined,
      nodeMimirs: globalThis.Array.isArray(object?.nodeMimirs)
        ? object.nodeMimirs.map((e: any) => NodeMimir.fromJSON(e))
        : [],
      affiliateCollectors: globalThis.Array.isArray(object?.affiliateCollectors)
        ? object.affiliateCollectors.map((e: any) =>
            AffiliateFeeCollector.fromJSON(e)
          )
        : [],
      loanTotalCollateral: globalThis.Array.isArray(object?.loanTotalCollateral)
        ? object.loanTotalCollateral.map((e: any) => Coin.fromJSON(e))
        : [],
      securedAssets: globalThis.Array.isArray(object?.securedAssets)
        ? object.securedAssets.map((e: any) => SecuredAsset.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GenesisState): unknown {
    const obj: any = {};
    if (message.pools?.length) {
      obj.pools = message.pools.map((e) => Pool.toJSON(e));
    }
    if (message.liquidityProviders?.length) {
      obj.liquidityProviders = message.liquidityProviders.map((e) =>
        LiquidityProvider.toJSON(e)
      );
    }
    if (message.observedTxInVoters?.length) {
      obj.observedTxInVoters = message.observedTxInVoters.map((e) =>
        ObservedTxVoter.toJSON(e)
      );
    }
    if (message.observedTxOutVoters?.length) {
      obj.observedTxOutVoters = message.observedTxOutVoters.map((e) =>
        ObservedTxVoter.toJSON(e)
      );
    }
    if (message.txOuts?.length) {
      obj.txOuts = message.txOuts.map((e) => TxOut.toJSON(e));
    }
    if (message.nodeAccounts?.length) {
      obj.nodeAccounts = message.nodeAccounts.map((e) => NodeAccount.toJSON(e));
    }
    if (message.vaults?.length) {
      obj.vaults = message.vaults.map((e) => Vault.toJSON(e));
    }
    if (message.reserve !== 0) {
      obj.reserve = Math.round(message.reserve);
    }
    if (message.lastSignedHeight !== 0) {
      obj.lastSignedHeight = Math.round(message.lastSignedHeight);
    }
    if (message.lastChainHeights?.length) {
      obj.lastChainHeights = message.lastChainHeights.map((e) =>
        lastChainHeight.toJSON(e)
      );
    }
    if (message.reserveContributors?.length) {
      obj.reserveContributors = message.reserveContributors.map((e) =>
        ReserveContributor.toJSON(e)
      );
    }
    if (message.network !== undefined) {
      obj.network = Network.toJSON(message.network);
    }
    if (message.orderbookItems?.length) {
      obj.orderbookItems = message.orderbookItems.map((e) => MsgSwap.toJSON(e));
    }
    if (message.networkFees?.length) {
      obj.networkFees = message.networkFees.map((e) => NetworkFee.toJSON(e));
    }
    if (message.chainContracts?.length) {
      obj.chainContracts = message.chainContracts.map((e) =>
        ChainContract.toJSON(e)
      );
    }
    if (message.THORNames?.length) {
      obj.THORNames = message.THORNames.map((e) => THORName.toJSON(e));
    }
    if (message.mimirs?.length) {
      obj.mimirs = message.mimirs.map((e) => mimir.toJSON(e));
    }
    if (message.storeVersion !== 0) {
      obj.storeVersion = Math.round(message.storeVersion);
    }
    if (message.bondProviders?.length) {
      obj.bondProviders = message.bondProviders.map((e) =>
        BondProviders.toJSON(e)
      );
    }
    if (message.POL !== undefined) {
      obj.POL = ProtocolOwnedLiquidity.toJSON(message.POL);
    }
    if (message.loans?.length) {
      obj.loans = message.loans.map((e) => Loan.toJSON(e));
    }
    if (message.streamingSwaps?.length) {
      obj.streamingSwaps = message.streamingSwaps.map((e) =>
        StreamingSwap.toJSON(e)
      );
    }
    if (message.swapQueueItems?.length) {
      obj.swapQueueItems = message.swapQueueItems.map((e) => MsgSwap.toJSON(e));
    }
    if (message.swapperClout?.length) {
      obj.swapperClout = message.swapperClout.map((e) =>
        SwapperClout.toJSON(e)
      );
    }
    if (message.tradeAccounts?.length) {
      obj.tradeAccounts = message.tradeAccounts.map((e) =>
        TradeAccount.toJSON(e)
      );
    }
    if (message.tradeUnits?.length) {
      obj.tradeUnits = message.tradeUnits.map((e) => TradeUnit.toJSON(e));
    }
    if (message.outboundFeeWithheldRune?.length) {
      obj.outboundFeeWithheldRune = message.outboundFeeWithheldRune.map((e) =>
        Coin.toJSON(e)
      );
    }
    if (message.outboundFeeSpentRune?.length) {
      obj.outboundFeeSpentRune = message.outboundFeeSpentRune.map((e) =>
        Coin.toJSON(e)
      );
    }
    if (message.runeProviders?.length) {
      obj.runeProviders = message.runeProviders.map((e) =>
        RUNEProvider.toJSON(e)
      );
    }
    if (message.runePool !== undefined) {
      obj.runePool = RUNEPool.toJSON(message.runePool);
    }
    if (message.nodeMimirs?.length) {
      obj.nodeMimirs = message.nodeMimirs.map((e) => NodeMimir.toJSON(e));
    }
    if (message.affiliateCollectors?.length) {
      obj.affiliateCollectors = message.affiliateCollectors.map((e) =>
        AffiliateFeeCollector.toJSON(e)
      );
    }
    if (message.loanTotalCollateral?.length) {
      obj.loanTotalCollateral = message.loanTotalCollateral.map((e) =>
        Coin.toJSON(e)
      );
    }
    if (message.securedAssets?.length) {
      obj.securedAssets = message.securedAssets.map((e) =>
        SecuredAsset.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GenesisState>, I>>(
    base?: I
  ): GenesisState {
    return GenesisState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GenesisState>, I>>(
    object: I
  ): GenesisState {
    const message = createBaseGenesisState();
    message.pools = object.pools?.map((e) => Pool.fromPartial(e)) || [];
    message.liquidityProviders =
      object.liquidityProviders?.map((e) => LiquidityProvider.fromPartial(e)) ||
      [];
    message.observedTxInVoters =
      object.observedTxInVoters?.map((e) => ObservedTxVoter.fromPartial(e)) ||
      [];
    message.observedTxOutVoters =
      object.observedTxOutVoters?.map((e) => ObservedTxVoter.fromPartial(e)) ||
      [];
    message.txOuts = object.txOuts?.map((e) => TxOut.fromPartial(e)) || [];
    message.nodeAccounts =
      object.nodeAccounts?.map((e) => NodeAccount.fromPartial(e)) || [];
    message.vaults = object.vaults?.map((e) => Vault.fromPartial(e)) || [];
    message.reserve = object.reserve ?? 0;
    message.lastSignedHeight = object.lastSignedHeight ?? 0;
    message.lastChainHeights =
      object.lastChainHeights?.map((e) => lastChainHeight.fromPartial(e)) || [];
    message.reserveContributors =
      object.reserveContributors?.map((e) =>
        ReserveContributor.fromPartial(e)
      ) || [];
    message.network =
      object.network !== undefined && object.network !== null
        ? Network.fromPartial(object.network)
        : undefined;
    message.orderbookItems =
      object.orderbookItems?.map((e) => MsgSwap.fromPartial(e)) || [];
    message.networkFees =
      object.networkFees?.map((e) => NetworkFee.fromPartial(e)) || [];
    message.chainContracts =
      object.chainContracts?.map((e) => ChainContract.fromPartial(e)) || [];
    message.THORNames =
      object.THORNames?.map((e) => THORName.fromPartial(e)) || [];
    message.mimirs = object.mimirs?.map((e) => mimir.fromPartial(e)) || [];
    message.storeVersion = object.storeVersion ?? 0;
    message.bondProviders =
      object.bondProviders?.map((e) => BondProviders.fromPartial(e)) || [];
    message.POL =
      object.POL !== undefined && object.POL !== null
        ? ProtocolOwnedLiquidity.fromPartial(object.POL)
        : undefined;
    message.loans = object.loans?.map((e) => Loan.fromPartial(e)) || [];
    message.streamingSwaps =
      object.streamingSwaps?.map((e) => StreamingSwap.fromPartial(e)) || [];
    message.swapQueueItems =
      object.swapQueueItems?.map((e) => MsgSwap.fromPartial(e)) || [];
    message.swapperClout =
      object.swapperClout?.map((e) => SwapperClout.fromPartial(e)) || [];
    message.tradeAccounts =
      object.tradeAccounts?.map((e) => TradeAccount.fromPartial(e)) || [];
    message.tradeUnits =
      object.tradeUnits?.map((e) => TradeUnit.fromPartial(e)) || [];
    message.outboundFeeWithheldRune =
      object.outboundFeeWithheldRune?.map((e) => Coin.fromPartial(e)) || [];
    message.outboundFeeSpentRune =
      object.outboundFeeSpentRune?.map((e) => Coin.fromPartial(e)) || [];
    message.runeProviders =
      object.runeProviders?.map((e) => RUNEProvider.fromPartial(e)) || [];
    message.runePool =
      object.runePool !== undefined && object.runePool !== null
        ? RUNEPool.fromPartial(object.runePool)
        : undefined;
    message.nodeMimirs =
      object.nodeMimirs?.map((e) => NodeMimir.fromPartial(e)) || [];
    message.affiliateCollectors =
      object.affiliateCollectors?.map((e) =>
        AffiliateFeeCollector.fromPartial(e)
      ) || [];
    message.loanTotalCollateral =
      object.loanTotalCollateral?.map((e) => Coin.fromPartial(e)) || [];
    message.securedAssets =
      object.securedAssets?.map((e) => SecuredAsset.fromPartial(e)) || [];
    return message;
  },
};
