// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               unknown
// source: types/type_streaming_swap.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "../../binary";
import { DeepPartial, Exact, isSet } from "../../helpers";
export const protobufPackage = "types";

export interface StreamingSwap {
  txId: string;
  interval: number;
  quantity: number;
  count: number;
  lastHeight: number;
  tradeTarget: string;
  deposit: string;
  in: string;
  out: string;
  failedSwaps: number[];
  failedSwapReasons: string[];
}

function createBaseStreamingSwap(): StreamingSwap {
  return {
    txId: "",
    interval: 0,
    quantity: 0,
    count: 0,
    lastHeight: 0,
    tradeTarget: "",
    deposit: "",
    in: "",
    out: "",
    failedSwaps: [],
    failedSwapReasons: [],
  };
}

export const StreamingSwap = {
  encode(
    message: StreamingSwap,
    writer: BinaryWriter = BinaryWriter.create()
  ): BinaryWriter {
    if (message.txId !== "") {
      writer.uint32(10).string(message.txId);
    }
    if (message.interval !== 0) {
      writer.uint32(16).uint64(message.interval);
    }
    if (message.quantity !== 0) {
      writer.uint32(24).uint64(message.quantity);
    }
    if (message.count !== 0) {
      writer.uint32(32).uint64(message.count);
    }
    if (message.lastHeight !== 0) {
      writer.uint32(40).int64(message.lastHeight);
    }
    if (message.tradeTarget !== "") {
      writer.uint32(50).string(message.tradeTarget);
    }
    if (message.deposit !== "") {
      writer.uint32(58).string(message.deposit);
    }
    if (message.in !== "") {
      writer.uint32(66).string(message.in);
    }
    if (message.out !== "") {
      writer.uint32(74).string(message.out);
    }
    writer.uint32(82).fork();
    for (const v of message.failedSwaps) {
      writer.uint64(v);
    }
    writer.ldelim();
    for (const v of message.failedSwapReasons) {
      writer.uint32(90).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamingSwap {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamingSwap();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.txId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.interval = Number(reader.uint64());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.quantity = Number(reader.uint64());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.count = Number(reader.uint64());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.lastHeight = Number(reader.int64());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.tradeTarget = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.deposit = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.in = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.out = reader.string();
          continue;
        case 10:
          if (tag === 80) {
            message.failedSwaps.push(Number(reader.uint64()));

            continue;
          }

          if (tag === 82) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.failedSwaps.push(Number(reader.uint64()));
            }

            continue;
          }

          break;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.failedSwapReasons.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamingSwap {
    return {
      txId: isSet(object.txId) ? globalThis.String(object.txId) : "",
      interval: isSet(object.interval) ? globalThis.Number(object.interval) : 0,
      quantity: isSet(object.quantity) ? globalThis.Number(object.quantity) : 0,
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
      lastHeight: isSet(object.lastHeight)
        ? globalThis.Number(object.lastHeight)
        : 0,
      tradeTarget: isSet(object.tradeTarget)
        ? globalThis.String(object.tradeTarget)
        : "",
      deposit: isSet(object.deposit) ? globalThis.String(object.deposit) : "",
      in: isSet(object.in) ? globalThis.String(object.in) : "",
      out: isSet(object.out) ? globalThis.String(object.out) : "",
      failedSwaps: globalThis.Array.isArray(object?.failedSwaps)
        ? object.failedSwaps.map((e: any) => globalThis.Number(e))
        : [],
      failedSwapReasons: globalThis.Array.isArray(object?.failedSwapReasons)
        ? object.failedSwapReasons.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: StreamingSwap): unknown {
    const obj: any = {};
    if (message.txId !== "") {
      obj.txId = message.txId;
    }
    if (message.interval !== 0) {
      obj.interval = Math.round(message.interval);
    }
    if (message.quantity !== 0) {
      obj.quantity = Math.round(message.quantity);
    }
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    if (message.lastHeight !== 0) {
      obj.lastHeight = Math.round(message.lastHeight);
    }
    if (message.tradeTarget !== "") {
      obj.tradeTarget = message.tradeTarget;
    }
    if (message.deposit !== "") {
      obj.deposit = message.deposit;
    }
    if (message.in !== "") {
      obj.in = message.in;
    }
    if (message.out !== "") {
      obj.out = message.out;
    }
    if (message.failedSwaps?.length) {
      obj.failedSwaps = message.failedSwaps.map((e) => Math.round(e));
    }
    if (message.failedSwapReasons?.length) {
      obj.failedSwapReasons = message.failedSwapReasons;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StreamingSwap>, I>>(
    base?: I
  ): StreamingSwap {
    return StreamingSwap.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StreamingSwap>, I>>(
    object: I
  ): StreamingSwap {
    const message = createBaseStreamingSwap();
    message.txId = object.txId ?? "";
    message.interval = object.interval ?? 0;
    message.quantity = object.quantity ?? 0;
    message.count = object.count ?? 0;
    message.lastHeight = object.lastHeight ?? 0;
    message.tradeTarget = object.tradeTarget ?? "";
    message.deposit = object.deposit ?? "";
    message.in = object.in ?? "";
    message.out = object.out ?? "";
    message.failedSwaps = object.failedSwaps?.map((e) => e) || [];
    message.failedSwapReasons = object.failedSwapReasons?.map((e) => e) || [];
    return message;
  },
};
