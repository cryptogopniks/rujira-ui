// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               unknown
// source: types/query_block.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "../../binary";
import { DeepPartial, Exact, isSet } from "../../helpers";
export const protobufPackage = "types";

export interface QueryBlockRequest {
  height: string;
}

export interface QueryBlockResponse {
  id: BlockResponseId | undefined;
  header: BlockResponseHeader | undefined;
  beginBlockEvents: BlockEvent[];
  endBlockEvents: BlockEvent[];
  txs: QueryBlockTx[];
}

export interface BlockResponseId {
  hash: string;
  parts: BlockResponseIdParts | undefined;
}

export interface BlockResponseIdParts {
  total: number;
  hash: string;
}

export interface BlockResponseHeader {
  version: BlockResponseHeaderVersion | undefined;
  chainId: string;
  height: number;
  time: string;
  lastBlockId: BlockResponseId | undefined;
  lastCommitHash: string;
  dataHash: string;
  validatorsHash: string;
  nextValidatorsHash: string;
  consensusHash: string;
  appHash: string;
  lastResultsHash: string;
  evidenceHash: string;
  proposerAddress: string;
}

export interface BlockResponseHeaderVersion {
  block: string;
  app: string;
}

export interface BlockEvent {
  eventKvPair: EventKeyValuePair[];
}

export interface EventKeyValuePair {
  key: string;
  value: string;
}

export interface QueryBlockTx {
  hash: string;
  tx: Uint8Array;
  result: BlockTxResult | undefined;
}

export interface BlockTxResult {
  code: number;
  data: string;
  log: string;
  info: string;
  gasWanted: string;
  gasUsed: string;
  events: BlockEvent[];
  codespace: string;
}

function createBaseQueryBlockRequest(): QueryBlockRequest {
  return { height: "" };
}

export const QueryBlockRequest = {
  encode(
    message: QueryBlockRequest,
    writer: BinaryWriter = BinaryWriter.create()
  ): BinaryWriter {
    if (message.height !== "") {
      writer.uint32(10).string(message.height);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryBlockRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryBlockRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.height = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryBlockRequest {
    return {
      height: isSet(object.height) ? globalThis.String(object.height) : "",
    };
  },

  toJSON(message: QueryBlockRequest): unknown {
    const obj: any = {};
    if (message.height !== "") {
      obj.height = message.height;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryBlockRequest>, I>>(
    base?: I
  ): QueryBlockRequest {
    return QueryBlockRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryBlockRequest>, I>>(
    object: I
  ): QueryBlockRequest {
    const message = createBaseQueryBlockRequest();
    message.height = object.height ?? "";
    return message;
  },
};

function createBaseQueryBlockResponse(): QueryBlockResponse {
  return {
    id: undefined,
    header: undefined,
    beginBlockEvents: [],
    endBlockEvents: [],
    txs: [],
  };
}

export const QueryBlockResponse = {
  encode(
    message: QueryBlockResponse,
    writer: BinaryWriter = BinaryWriter.create()
  ): BinaryWriter {
    if (message.id !== undefined) {
      BlockResponseId.encode(message.id, writer.uint32(10).fork()).ldelim();
    }
    if (message.header !== undefined) {
      BlockResponseHeader.encode(
        message.header,
        writer.uint32(18).fork()
      ).ldelim();
    }
    for (const v of message.beginBlockEvents) {
      BlockEvent.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.endBlockEvents) {
      BlockEvent.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.txs) {
      QueryBlockTx.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): QueryBlockResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryBlockResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = BlockResponseId.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.header = BlockResponseHeader.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.beginBlockEvents.push(
            BlockEvent.decode(reader, reader.uint32())
          );
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.endBlockEvents.push(
            BlockEvent.decode(reader, reader.uint32())
          );
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.txs.push(QueryBlockTx.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryBlockResponse {
    return {
      id: isSet(object.id) ? BlockResponseId.fromJSON(object.id) : undefined,
      header: isSet(object.header)
        ? BlockResponseHeader.fromJSON(object.header)
        : undefined,
      beginBlockEvents: globalThis.Array.isArray(object?.beginBlockEvents)
        ? object.beginBlockEvents.map((e: any) => BlockEvent.fromJSON(e))
        : [],
      endBlockEvents: globalThis.Array.isArray(object?.endBlockEvents)
        ? object.endBlockEvents.map((e: any) => BlockEvent.fromJSON(e))
        : [],
      txs: globalThis.Array.isArray(object?.txs)
        ? object.txs.map((e: any) => QueryBlockTx.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryBlockResponse): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = BlockResponseId.toJSON(message.id);
    }
    if (message.header !== undefined) {
      obj.header = BlockResponseHeader.toJSON(message.header);
    }
    if (message.beginBlockEvents?.length) {
      obj.beginBlockEvents = message.beginBlockEvents.map((e) =>
        BlockEvent.toJSON(e)
      );
    }
    if (message.endBlockEvents?.length) {
      obj.endBlockEvents = message.endBlockEvents.map((e) =>
        BlockEvent.toJSON(e)
      );
    }
    if (message.txs?.length) {
      obj.txs = message.txs.map((e) => QueryBlockTx.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryBlockResponse>, I>>(
    base?: I
  ): QueryBlockResponse {
    return QueryBlockResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryBlockResponse>, I>>(
    object: I
  ): QueryBlockResponse {
    const message = createBaseQueryBlockResponse();
    message.id =
      object.id !== undefined && object.id !== null
        ? BlockResponseId.fromPartial(object.id)
        : undefined;
    message.header =
      object.header !== undefined && object.header !== null
        ? BlockResponseHeader.fromPartial(object.header)
        : undefined;
    message.beginBlockEvents =
      object.beginBlockEvents?.map((e) => BlockEvent.fromPartial(e)) || [];
    message.endBlockEvents =
      object.endBlockEvents?.map((e) => BlockEvent.fromPartial(e)) || [];
    message.txs = object.txs?.map((e) => QueryBlockTx.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBlockResponseId(): BlockResponseId {
  return { hash: "", parts: undefined };
}

export const BlockResponseId = {
  encode(
    message: BlockResponseId,
    writer: BinaryWriter = BinaryWriter.create()
  ): BinaryWriter {
    if (message.hash !== "") {
      writer.uint32(10).string(message.hash);
    }
    if (message.parts !== undefined) {
      BlockResponseIdParts.encode(
        message.parts,
        writer.uint32(18).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockResponseId {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockResponseId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.hash = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.parts = BlockResponseIdParts.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockResponseId {
    return {
      hash: isSet(object.hash) ? globalThis.String(object.hash) : "",
      parts: isSet(object.parts)
        ? BlockResponseIdParts.fromJSON(object.parts)
        : undefined,
    };
  },

  toJSON(message: BlockResponseId): unknown {
    const obj: any = {};
    if (message.hash !== "") {
      obj.hash = message.hash;
    }
    if (message.parts !== undefined) {
      obj.parts = BlockResponseIdParts.toJSON(message.parts);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockResponseId>, I>>(
    base?: I
  ): BlockResponseId {
    return BlockResponseId.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockResponseId>, I>>(
    object: I
  ): BlockResponseId {
    const message = createBaseBlockResponseId();
    message.hash = object.hash ?? "";
    message.parts =
      object.parts !== undefined && object.parts !== null
        ? BlockResponseIdParts.fromPartial(object.parts)
        : undefined;
    return message;
  },
};

function createBaseBlockResponseIdParts(): BlockResponseIdParts {
  return { total: 0, hash: "" };
}

export const BlockResponseIdParts = {
  encode(
    message: BlockResponseIdParts,
    writer: BinaryWriter = BinaryWriter.create()
  ): BinaryWriter {
    if (message.total !== 0) {
      writer.uint32(8).int64(message.total);
    }
    if (message.hash !== "") {
      writer.uint32(18).string(message.hash);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): BlockResponseIdParts {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockResponseIdParts();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.total = Number(reader.int64());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.hash = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockResponseIdParts {
    return {
      total: isSet(object.total) ? globalThis.Number(object.total) : 0,
      hash: isSet(object.hash) ? globalThis.String(object.hash) : "",
    };
  },

  toJSON(message: BlockResponseIdParts): unknown {
    const obj: any = {};
    if (message.total !== 0) {
      obj.total = Math.round(message.total);
    }
    if (message.hash !== "") {
      obj.hash = message.hash;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockResponseIdParts>, I>>(
    base?: I
  ): BlockResponseIdParts {
    return BlockResponseIdParts.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockResponseIdParts>, I>>(
    object: I
  ): BlockResponseIdParts {
    const message = createBaseBlockResponseIdParts();
    message.total = object.total ?? 0;
    message.hash = object.hash ?? "";
    return message;
  },
};

function createBaseBlockResponseHeader(): BlockResponseHeader {
  return {
    version: undefined,
    chainId: "",
    height: 0,
    time: "",
    lastBlockId: undefined,
    lastCommitHash: "",
    dataHash: "",
    validatorsHash: "",
    nextValidatorsHash: "",
    consensusHash: "",
    appHash: "",
    lastResultsHash: "",
    evidenceHash: "",
    proposerAddress: "",
  };
}

export const BlockResponseHeader = {
  encode(
    message: BlockResponseHeader,
    writer: BinaryWriter = BinaryWriter.create()
  ): BinaryWriter {
    if (message.version !== undefined) {
      BlockResponseHeaderVersion.encode(
        message.version,
        writer.uint32(10).fork()
      ).ldelim();
    }
    if (message.chainId !== "") {
      writer.uint32(18).string(message.chainId);
    }
    if (message.height !== 0) {
      writer.uint32(24).int64(message.height);
    }
    if (message.time !== "") {
      writer.uint32(34).string(message.time);
    }
    if (message.lastBlockId !== undefined) {
      BlockResponseId.encode(
        message.lastBlockId,
        writer.uint32(42).fork()
      ).ldelim();
    }
    if (message.lastCommitHash !== "") {
      writer.uint32(50).string(message.lastCommitHash);
    }
    if (message.dataHash !== "") {
      writer.uint32(58).string(message.dataHash);
    }
    if (message.validatorsHash !== "") {
      writer.uint32(66).string(message.validatorsHash);
    }
    if (message.nextValidatorsHash !== "") {
      writer.uint32(74).string(message.nextValidatorsHash);
    }
    if (message.consensusHash !== "") {
      writer.uint32(82).string(message.consensusHash);
    }
    if (message.appHash !== "") {
      writer.uint32(90).string(message.appHash);
    }
    if (message.lastResultsHash !== "") {
      writer.uint32(98).string(message.lastResultsHash);
    }
    if (message.evidenceHash !== "") {
      writer.uint32(106).string(message.evidenceHash);
    }
    if (message.proposerAddress !== "") {
      writer.uint32(114).string(message.proposerAddress);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): BlockResponseHeader {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockResponseHeader();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.version = BlockResponseHeaderVersion.decode(
            reader,
            reader.uint32()
          );
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.height = Number(reader.int64());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.time = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.lastBlockId = BlockResponseId.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.lastCommitHash = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.dataHash = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.validatorsHash = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.nextValidatorsHash = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.consensusHash = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.appHash = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.lastResultsHash = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.evidenceHash = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.proposerAddress = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockResponseHeader {
    return {
      version: isSet(object.version)
        ? BlockResponseHeaderVersion.fromJSON(object.version)
        : undefined,
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
      time: isSet(object.time) ? globalThis.String(object.time) : "",
      lastBlockId: isSet(object.lastBlockId)
        ? BlockResponseId.fromJSON(object.lastBlockId)
        : undefined,
      lastCommitHash: isSet(object.lastCommitHash)
        ? globalThis.String(object.lastCommitHash)
        : "",
      dataHash: isSet(object.dataHash)
        ? globalThis.String(object.dataHash)
        : "",
      validatorsHash: isSet(object.validatorsHash)
        ? globalThis.String(object.validatorsHash)
        : "",
      nextValidatorsHash: isSet(object.nextValidatorsHash)
        ? globalThis.String(object.nextValidatorsHash)
        : "",
      consensusHash: isSet(object.consensusHash)
        ? globalThis.String(object.consensusHash)
        : "",
      appHash: isSet(object.appHash) ? globalThis.String(object.appHash) : "",
      lastResultsHash: isSet(object.lastResultsHash)
        ? globalThis.String(object.lastResultsHash)
        : "",
      evidenceHash: isSet(object.evidenceHash)
        ? globalThis.String(object.evidenceHash)
        : "",
      proposerAddress: isSet(object.proposerAddress)
        ? globalThis.String(object.proposerAddress)
        : "",
    };
  },

  toJSON(message: BlockResponseHeader): unknown {
    const obj: any = {};
    if (message.version !== undefined) {
      obj.version = BlockResponseHeaderVersion.toJSON(message.version);
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    if (message.time !== "") {
      obj.time = message.time;
    }
    if (message.lastBlockId !== undefined) {
      obj.lastBlockId = BlockResponseId.toJSON(message.lastBlockId);
    }
    if (message.lastCommitHash !== "") {
      obj.lastCommitHash = message.lastCommitHash;
    }
    if (message.dataHash !== "") {
      obj.dataHash = message.dataHash;
    }
    if (message.validatorsHash !== "") {
      obj.validatorsHash = message.validatorsHash;
    }
    if (message.nextValidatorsHash !== "") {
      obj.nextValidatorsHash = message.nextValidatorsHash;
    }
    if (message.consensusHash !== "") {
      obj.consensusHash = message.consensusHash;
    }
    if (message.appHash !== "") {
      obj.appHash = message.appHash;
    }
    if (message.lastResultsHash !== "") {
      obj.lastResultsHash = message.lastResultsHash;
    }
    if (message.evidenceHash !== "") {
      obj.evidenceHash = message.evidenceHash;
    }
    if (message.proposerAddress !== "") {
      obj.proposerAddress = message.proposerAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockResponseHeader>, I>>(
    base?: I
  ): BlockResponseHeader {
    return BlockResponseHeader.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockResponseHeader>, I>>(
    object: I
  ): BlockResponseHeader {
    const message = createBaseBlockResponseHeader();
    message.version =
      object.version !== undefined && object.version !== null
        ? BlockResponseHeaderVersion.fromPartial(object.version)
        : undefined;
    message.chainId = object.chainId ?? "";
    message.height = object.height ?? 0;
    message.time = object.time ?? "";
    message.lastBlockId =
      object.lastBlockId !== undefined && object.lastBlockId !== null
        ? BlockResponseId.fromPartial(object.lastBlockId)
        : undefined;
    message.lastCommitHash = object.lastCommitHash ?? "";
    message.dataHash = object.dataHash ?? "";
    message.validatorsHash = object.validatorsHash ?? "";
    message.nextValidatorsHash = object.nextValidatorsHash ?? "";
    message.consensusHash = object.consensusHash ?? "";
    message.appHash = object.appHash ?? "";
    message.lastResultsHash = object.lastResultsHash ?? "";
    message.evidenceHash = object.evidenceHash ?? "";
    message.proposerAddress = object.proposerAddress ?? "";
    return message;
  },
};

function createBaseBlockResponseHeaderVersion(): BlockResponseHeaderVersion {
  return { block: "", app: "" };
}

export const BlockResponseHeaderVersion = {
  encode(
    message: BlockResponseHeaderVersion,
    writer: BinaryWriter = BinaryWriter.create()
  ): BinaryWriter {
    if (message.block !== "") {
      writer.uint32(10).string(message.block);
    }
    if (message.app !== "") {
      writer.uint32(18).string(message.app);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): BlockResponseHeaderVersion {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockResponseHeaderVersion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.block = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.app = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockResponseHeaderVersion {
    return {
      block: isSet(object.block) ? globalThis.String(object.block) : "",
      app: isSet(object.app) ? globalThis.String(object.app) : "",
    };
  },

  toJSON(message: BlockResponseHeaderVersion): unknown {
    const obj: any = {};
    if (message.block !== "") {
      obj.block = message.block;
    }
    if (message.app !== "") {
      obj.app = message.app;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockResponseHeaderVersion>, I>>(
    base?: I
  ): BlockResponseHeaderVersion {
    return BlockResponseHeaderVersion.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockResponseHeaderVersion>, I>>(
    object: I
  ): BlockResponseHeaderVersion {
    const message = createBaseBlockResponseHeaderVersion();
    message.block = object.block ?? "";
    message.app = object.app ?? "";
    return message;
  },
};

function createBaseBlockEvent(): BlockEvent {
  return { eventKvPair: [] };
}

export const BlockEvent = {
  encode(
    message: BlockEvent,
    writer: BinaryWriter = BinaryWriter.create()
  ): BinaryWriter {
    for (const v of message.eventKvPair) {
      EventKeyValuePair.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockEvent {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.eventKvPair.push(
            EventKeyValuePair.decode(reader, reader.uint32())
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockEvent {
    return {
      eventKvPair: globalThis.Array.isArray(object?.eventKvPair)
        ? object.eventKvPair.map((e: any) => EventKeyValuePair.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BlockEvent): unknown {
    const obj: any = {};
    if (message.eventKvPair?.length) {
      obj.eventKvPair = message.eventKvPair.map((e) =>
        EventKeyValuePair.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockEvent>, I>>(base?: I): BlockEvent {
    return BlockEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockEvent>, I>>(
    object: I
  ): BlockEvent {
    const message = createBaseBlockEvent();
    message.eventKvPair =
      object.eventKvPair?.map((e) => EventKeyValuePair.fromPartial(e)) || [];
    return message;
  },
};

function createBaseEventKeyValuePair(): EventKeyValuePair {
  return { key: "", value: "" };
}

export const EventKeyValuePair = {
  encode(
    message: EventKeyValuePair,
    writer: BinaryWriter = BinaryWriter.create()
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventKeyValuePair {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventKeyValuePair();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventKeyValuePair {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: EventKeyValuePair): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventKeyValuePair>, I>>(
    base?: I
  ): EventKeyValuePair {
    return EventKeyValuePair.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventKeyValuePair>, I>>(
    object: I
  ): EventKeyValuePair {
    const message = createBaseEventKeyValuePair();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseQueryBlockTx(): QueryBlockTx {
  return { hash: "", tx: new Uint8Array(0), result: undefined };
}

export const QueryBlockTx = {
  encode(
    message: QueryBlockTx,
    writer: BinaryWriter = BinaryWriter.create()
  ): BinaryWriter {
    if (message.hash !== "") {
      writer.uint32(10).string(message.hash);
    }
    if (message.tx.length !== 0) {
      writer.uint32(18).bytes(message.tx);
    }
    if (message.result !== undefined) {
      BlockTxResult.encode(message.result, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryBlockTx {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryBlockTx();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.hash = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.tx = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.result = BlockTxResult.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryBlockTx {
    return {
      hash: isSet(object.hash) ? globalThis.String(object.hash) : "",
      tx: isSet(object.tx) ? bytesFromBase64(object.tx) : new Uint8Array(0),
      result: isSet(object.result)
        ? BlockTxResult.fromJSON(object.result)
        : undefined,
    };
  },

  toJSON(message: QueryBlockTx): unknown {
    const obj: any = {};
    if (message.hash !== "") {
      obj.hash = message.hash;
    }
    if (message.tx.length !== 0) {
      obj.tx = base64FromBytes(message.tx);
    }
    if (message.result !== undefined) {
      obj.result = BlockTxResult.toJSON(message.result);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryBlockTx>, I>>(
    base?: I
  ): QueryBlockTx {
    return QueryBlockTx.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryBlockTx>, I>>(
    object: I
  ): QueryBlockTx {
    const message = createBaseQueryBlockTx();
    message.hash = object.hash ?? "";
    message.tx = object.tx ?? new Uint8Array(0);
    message.result =
      object.result !== undefined && object.result !== null
        ? BlockTxResult.fromPartial(object.result)
        : undefined;
    return message;
  },
};

function createBaseBlockTxResult(): BlockTxResult {
  return {
    code: 0,
    data: "",
    log: "",
    info: "",
    gasWanted: "",
    gasUsed: "",
    events: [],
    codespace: "",
  };
}

export const BlockTxResult = {
  encode(
    message: BlockTxResult,
    writer: BinaryWriter = BinaryWriter.create()
  ): BinaryWriter {
    if (message.code !== 0) {
      writer.uint32(8).int64(message.code);
    }
    if (message.data !== "") {
      writer.uint32(18).string(message.data);
    }
    if (message.log !== "") {
      writer.uint32(26).string(message.log);
    }
    if (message.info !== "") {
      writer.uint32(34).string(message.info);
    }
    if (message.gasWanted !== "") {
      writer.uint32(42).string(message.gasWanted);
    }
    if (message.gasUsed !== "") {
      writer.uint32(50).string(message.gasUsed);
    }
    for (const v of message.events) {
      BlockEvent.encode(v!, writer.uint32(58).fork()).ldelim();
    }
    if (message.codespace !== "") {
      writer.uint32(66).string(message.codespace);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockTxResult {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockTxResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.code = Number(reader.int64());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.data = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.log = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.info = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.gasWanted = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.gasUsed = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.events.push(BlockEvent.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.codespace = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockTxResult {
    return {
      code: isSet(object.code) ? globalThis.Number(object.code) : 0,
      data: isSet(object.data) ? globalThis.String(object.data) : "",
      log: isSet(object.log) ? globalThis.String(object.log) : "",
      info: isSet(object.info) ? globalThis.String(object.info) : "",
      gasWanted: isSet(object.gasWanted)
        ? globalThis.String(object.gasWanted)
        : "",
      gasUsed: isSet(object.gasUsed) ? globalThis.String(object.gasUsed) : "",
      events: globalThis.Array.isArray(object?.events)
        ? object.events.map((e: any) => BlockEvent.fromJSON(e))
        : [],
      codespace: isSet(object.codespace)
        ? globalThis.String(object.codespace)
        : "",
    };
  },

  toJSON(message: BlockTxResult): unknown {
    const obj: any = {};
    if (message.code !== 0) {
      obj.code = Math.round(message.code);
    }
    if (message.data !== "") {
      obj.data = message.data;
    }
    if (message.log !== "") {
      obj.log = message.log;
    }
    if (message.info !== "") {
      obj.info = message.info;
    }
    if (message.gasWanted !== "") {
      obj.gasWanted = message.gasWanted;
    }
    if (message.gasUsed !== "") {
      obj.gasUsed = message.gasUsed;
    }
    if (message.events?.length) {
      obj.events = message.events.map((e) => BlockEvent.toJSON(e));
    }
    if (message.codespace !== "") {
      obj.codespace = message.codespace;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockTxResult>, I>>(
    base?: I
  ): BlockTxResult {
    return BlockTxResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockTxResult>, I>>(
    object: I
  ): BlockTxResult {
    const message = createBaseBlockTxResult();
    message.code = object.code ?? 0;
    message.data = object.data ?? "";
    message.log = object.log ?? "";
    message.info = object.info ?? "";
    message.gasWanted = object.gasWanted ?? "";
    message.gasUsed = object.gasUsed ?? "";
    message.events = object.events?.map((e) => BlockEvent.fromPartial(e)) || [];
    message.codespace = object.codespace ?? "";
    return message;
  },
};
