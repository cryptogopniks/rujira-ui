// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               unknown
// source: types/query_streaming_swap.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "../../binary";
import { DeepPartial, Exact, isSet } from "../../helpers";
export const protobufPackage = "types";

export interface QueryStreamingSwapRequest {
  txId: string;
  height: string;
}

export interface QueryStreamingSwapResponse {
  /** the hash of a transaction */
  txId: string;
  /** how often each swap is made, in blocks */
  interval: number;
  /** the total number of swaps in a streaming swaps */
  quantity: number;
  /** the amount of swap attempts so far */
  count: number;
  /** the block height of the latest swap */
  lastHeight: number;
  /** the total number of tokens the swapper wants to receive of the output asset */
  tradeTarget: string;
  /** the asset to be swapped from */
  sourceAsset: string;
  /** the asset to be swapped to */
  targetAsset: string;
  /** the destination address to receive the swap output */
  destination: string;
  /** the number of input tokens the swapper has deposited */
  deposit: string;
  /** the amount of input tokens that have been swapped so far */
  in: string;
  /** the amount of output tokens that have been swapped so far */
  out: string;
  /** the list of swap indexes that failed */
  failedSwaps: number[];
  /** the list of reasons that sub-swaps have failed */
  failedSwapReasons: string[];
}

export interface QueryStreamingSwapsRequest {
  height: string;
}

export interface QueryStreamingSwapsResponse {
  streamingSwaps: QueryStreamingSwapResponse[];
}

function createBaseQueryStreamingSwapRequest(): QueryStreamingSwapRequest {
  return { txId: "", height: "" };
}

export const QueryStreamingSwapRequest = {
  encode(
    message: QueryStreamingSwapRequest,
    writer: BinaryWriter = BinaryWriter.create()
  ): BinaryWriter {
    if (message.txId !== "") {
      writer.uint32(10).string(message.txId);
    }
    if (message.height !== "") {
      writer.uint32(18).string(message.height);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): QueryStreamingSwapRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryStreamingSwapRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.txId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.height = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryStreamingSwapRequest {
    return {
      txId: isSet(object.txId) ? globalThis.String(object.txId) : "",
      height: isSet(object.height) ? globalThis.String(object.height) : "",
    };
  },

  toJSON(message: QueryStreamingSwapRequest): unknown {
    const obj: any = {};
    if (message.txId !== "") {
      obj.txId = message.txId;
    }
    if (message.height !== "") {
      obj.height = message.height;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryStreamingSwapRequest>, I>>(
    base?: I
  ): QueryStreamingSwapRequest {
    return QueryStreamingSwapRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryStreamingSwapRequest>, I>>(
    object: I
  ): QueryStreamingSwapRequest {
    const message = createBaseQueryStreamingSwapRequest();
    message.txId = object.txId ?? "";
    message.height = object.height ?? "";
    return message;
  },
};

function createBaseQueryStreamingSwapResponse(): QueryStreamingSwapResponse {
  return {
    txId: "",
    interval: 0,
    quantity: 0,
    count: 0,
    lastHeight: 0,
    tradeTarget: "",
    sourceAsset: "",
    targetAsset: "",
    destination: "",
    deposit: "",
    in: "",
    out: "",
    failedSwaps: [],
    failedSwapReasons: [],
  };
}

export const QueryStreamingSwapResponse = {
  encode(
    message: QueryStreamingSwapResponse,
    writer: BinaryWriter = BinaryWriter.create()
  ): BinaryWriter {
    if (message.txId !== "") {
      writer.uint32(10).string(message.txId);
    }
    if (message.interval !== 0) {
      writer.uint32(16).int64(message.interval);
    }
    if (message.quantity !== 0) {
      writer.uint32(24).int64(message.quantity);
    }
    if (message.count !== 0) {
      writer.uint32(32).int64(message.count);
    }
    if (message.lastHeight !== 0) {
      writer.uint32(40).int64(message.lastHeight);
    }
    if (message.tradeTarget !== "") {
      writer.uint32(50).string(message.tradeTarget);
    }
    if (message.sourceAsset !== "") {
      writer.uint32(58).string(message.sourceAsset);
    }
    if (message.targetAsset !== "") {
      writer.uint32(66).string(message.targetAsset);
    }
    if (message.destination !== "") {
      writer.uint32(74).string(message.destination);
    }
    if (message.deposit !== "") {
      writer.uint32(82).string(message.deposit);
    }
    if (message.in !== "") {
      writer.uint32(90).string(message.in);
    }
    if (message.out !== "") {
      writer.uint32(98).string(message.out);
    }
    writer.uint32(106).fork();
    for (const v of message.failedSwaps) {
      writer.int64(v);
    }
    writer.ldelim();
    for (const v of message.failedSwapReasons) {
      writer.uint32(114).string(v!);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): QueryStreamingSwapResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryStreamingSwapResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.txId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.interval = Number(reader.int64());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.quantity = Number(reader.int64());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.count = Number(reader.int64());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.lastHeight = Number(reader.int64());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.tradeTarget = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.sourceAsset = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.targetAsset = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.destination = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.deposit = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.in = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.out = reader.string();
          continue;
        case 13:
          if (tag === 104) {
            message.failedSwaps.push(Number(reader.int64()));

            continue;
          }

          if (tag === 106) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.failedSwaps.push(Number(reader.int64()));
            }

            continue;
          }

          break;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.failedSwapReasons.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryStreamingSwapResponse {
    return {
      txId: isSet(object.txId) ? globalThis.String(object.txId) : "",
      interval: isSet(object.interval) ? globalThis.Number(object.interval) : 0,
      quantity: isSet(object.quantity) ? globalThis.Number(object.quantity) : 0,
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
      lastHeight: isSet(object.lastHeight)
        ? globalThis.Number(object.lastHeight)
        : 0,
      tradeTarget: isSet(object.tradeTarget)
        ? globalThis.String(object.tradeTarget)
        : "",
      sourceAsset: isSet(object.sourceAsset)
        ? globalThis.String(object.sourceAsset)
        : "",
      targetAsset: isSet(object.targetAsset)
        ? globalThis.String(object.targetAsset)
        : "",
      destination: isSet(object.destination)
        ? globalThis.String(object.destination)
        : "",
      deposit: isSet(object.deposit) ? globalThis.String(object.deposit) : "",
      in: isSet(object.in) ? globalThis.String(object.in) : "",
      out: isSet(object.out) ? globalThis.String(object.out) : "",
      failedSwaps: globalThis.Array.isArray(object?.failedSwaps)
        ? object.failedSwaps.map((e: any) => globalThis.Number(e))
        : [],
      failedSwapReasons: globalThis.Array.isArray(object?.failedSwapReasons)
        ? object.failedSwapReasons.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: QueryStreamingSwapResponse): unknown {
    const obj: any = {};
    if (message.txId !== "") {
      obj.txId = message.txId;
    }
    if (message.interval !== 0) {
      obj.interval = Math.round(message.interval);
    }
    if (message.quantity !== 0) {
      obj.quantity = Math.round(message.quantity);
    }
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    if (message.lastHeight !== 0) {
      obj.lastHeight = Math.round(message.lastHeight);
    }
    if (message.tradeTarget !== "") {
      obj.tradeTarget = message.tradeTarget;
    }
    if (message.sourceAsset !== "") {
      obj.sourceAsset = message.sourceAsset;
    }
    if (message.targetAsset !== "") {
      obj.targetAsset = message.targetAsset;
    }
    if (message.destination !== "") {
      obj.destination = message.destination;
    }
    if (message.deposit !== "") {
      obj.deposit = message.deposit;
    }
    if (message.in !== "") {
      obj.in = message.in;
    }
    if (message.out !== "") {
      obj.out = message.out;
    }
    if (message.failedSwaps?.length) {
      obj.failedSwaps = message.failedSwaps.map((e) => Math.round(e));
    }
    if (message.failedSwapReasons?.length) {
      obj.failedSwapReasons = message.failedSwapReasons;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryStreamingSwapResponse>, I>>(
    base?: I
  ): QueryStreamingSwapResponse {
    return QueryStreamingSwapResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryStreamingSwapResponse>, I>>(
    object: I
  ): QueryStreamingSwapResponse {
    const message = createBaseQueryStreamingSwapResponse();
    message.txId = object.txId ?? "";
    message.interval = object.interval ?? 0;
    message.quantity = object.quantity ?? 0;
    message.count = object.count ?? 0;
    message.lastHeight = object.lastHeight ?? 0;
    message.tradeTarget = object.tradeTarget ?? "";
    message.sourceAsset = object.sourceAsset ?? "";
    message.targetAsset = object.targetAsset ?? "";
    message.destination = object.destination ?? "";
    message.deposit = object.deposit ?? "";
    message.in = object.in ?? "";
    message.out = object.out ?? "";
    message.failedSwaps = object.failedSwaps?.map((e) => e) || [];
    message.failedSwapReasons = object.failedSwapReasons?.map((e) => e) || [];
    return message;
  },
};

function createBaseQueryStreamingSwapsRequest(): QueryStreamingSwapsRequest {
  return { height: "" };
}

export const QueryStreamingSwapsRequest = {
  encode(
    message: QueryStreamingSwapsRequest,
    writer: BinaryWriter = BinaryWriter.create()
  ): BinaryWriter {
    if (message.height !== "") {
      writer.uint32(10).string(message.height);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): QueryStreamingSwapsRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryStreamingSwapsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.height = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryStreamingSwapsRequest {
    return {
      height: isSet(object.height) ? globalThis.String(object.height) : "",
    };
  },

  toJSON(message: QueryStreamingSwapsRequest): unknown {
    const obj: any = {};
    if (message.height !== "") {
      obj.height = message.height;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryStreamingSwapsRequest>, I>>(
    base?: I
  ): QueryStreamingSwapsRequest {
    return QueryStreamingSwapsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryStreamingSwapsRequest>, I>>(
    object: I
  ): QueryStreamingSwapsRequest {
    const message = createBaseQueryStreamingSwapsRequest();
    message.height = object.height ?? "";
    return message;
  },
};

function createBaseQueryStreamingSwapsResponse(): QueryStreamingSwapsResponse {
  return { streamingSwaps: [] };
}

export const QueryStreamingSwapsResponse = {
  encode(
    message: QueryStreamingSwapsResponse,
    writer: BinaryWriter = BinaryWriter.create()
  ): BinaryWriter {
    for (const v of message.streamingSwaps) {
      QueryStreamingSwapResponse.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): QueryStreamingSwapsResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryStreamingSwapsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.streamingSwaps.push(
            QueryStreamingSwapResponse.decode(reader, reader.uint32())
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryStreamingSwapsResponse {
    return {
      streamingSwaps: globalThis.Array.isArray(object?.streamingSwaps)
        ? object.streamingSwaps.map((e: any) =>
            QueryStreamingSwapResponse.fromJSON(e)
          )
        : [],
    };
  },

  toJSON(message: QueryStreamingSwapsResponse): unknown {
    const obj: any = {};
    if (message.streamingSwaps?.length) {
      obj.streamingSwaps = message.streamingSwaps.map((e) =>
        QueryStreamingSwapResponse.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryStreamingSwapsResponse>, I>>(
    base?: I
  ): QueryStreamingSwapsResponse {
    return QueryStreamingSwapsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryStreamingSwapsResponse>, I>>(
    object: I
  ): QueryStreamingSwapsResponse {
    const message = createBaseQueryStreamingSwapsResponse();
    message.streamingSwaps =
      object.streamingSwaps?.map((e) =>
        QueryStreamingSwapResponse.fromPartial(e)
      ) || [];
    return message;
  },
};
